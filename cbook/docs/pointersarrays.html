<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>8. Pointers and more arrays &#8212; The Book of C (version 2022.08)</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/sphinxdoc.css?v=d59dc883" />
    <script src="_static/documentation_options.js?v=f827e75a"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="9. Program structure and compilation" href="programstructure.html" />
    <link rel="prev" title="7. Functions" href="functions.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="programstructure.html" title="9. Program structure and compilation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="7. Functions"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The Book of C (version 2022.08)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Pointers and more arrays</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="pointers-and-more-arrays">
<span id="pointers"></span><h1><span class="section-number">8. </span>Pointers and more arrays<a class="headerlink" href="#pointers-and-more-arrays" title="Link to this heading">¶</a></h1>
<p>The C programming language has a somewhat split personality.  On the one hand, it is a <em>high-level programming language</em> <a class="footnote-reference brackets" href="#f1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> in that it provides basic control and data abstractions so that a programmer does not have to work in low-level assembly code.  On the other hand, it is often considered a fairly <em>low-level language</em> <a class="footnote-reference brackets" href="#f2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> due to the fact that it provides only simple data types that directly reflect standard hardware capabilities (e.g., integers, floating point numbers, and simple character strings) and that it allows programmers to directly manipulate memory and memory addresses.  In this chapter, we focus on C's capabilities for enabling a programmer to directly manipulate memory and memory addresses.</p>
<aside class="topic" id="addr-space">
<span id="index-0"></span><p class="topic-title">Process address spaces</p>
<p>As a bit of context for discussing memory addresses and pointers, consider the following depiction of the <em>address space</em> of a running program (a &quot;process&quot;).</p>
<img alt="_images/addressspace.png" class="align-center" src="_images/addressspace.png" />
<p>A process in memory typically has (at least) 4 different portions of memory (&quot;segments&quot;) dedicated to different purposes.  For example, the binary machine code for the program must reside in memory, and a segment is dedicated to storage for global (&quot;static&quot;) variables.  These portions of memory typically remain <em>constant</em> in size, e.g., the amount of memory used for program code does not need to change.  There are two segments, however, that are designed to grow and shrink over the lifetime of a process: the <em>stack</em> and the <em>heap</em>.  The stack holds data for each function in progress, including space for local variables, space for parameters, and space for return values.  For each function call and return, the size of the stack will grow or shrink, respectively.  The heap contains storage for dynamic data structures, e.g., data objects in linked lists, which are managed by the programmer.</p>
</aside>
<section id="id3">
<h2><span class="section-number">8.1. </span>Pointers<a class="headerlink" href="#id3" title="Link to this heading">¶</a></h2>
<p>A <em>pointer</em> is a variable that holds a memory address.  The C language allows a programmer to manipulate data <em>indirectly</em> through a pointer variable, as well as manipulate the memory address itself stored in the pointer variable.</p>
<section id="declaration-syntax">
<span id="index-1"></span><h3><span class="section-number">8.1.1. </span>Declaration syntax<a class="headerlink" href="#declaration-syntax" title="Link to this heading">¶</a></h3>
<p>Declaring a new pointer variable is accomplished by using the syntax <code class="docutils literal notranslate"><span class="pre">&lt;data-type&gt;</span> <span class="pre">*&lt;variable-name&gt;;</span></code>  The asterisk symbol between the data type and variable name indicates that the variable holds a memory address that refers to a location holding the given data type.  For example, the following declaration creates a variable <code class="docutils literal notranslate"><span class="pre">p</span></code> that contains a memory address referring to a location holding an <code class="docutils literal notranslate"><span class="pre">int</span></code> type.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="c1">// p points to ???</span>
</pre></div>
</div>
<p>Recall that C does not do any automatic initialization of variables.  Thus, the variable <code class="docutils literal notranslate"><span class="pre">p</span></code> will hold an <em>undefined</em> memory address after the above declaration.  To initialize the pointer so that it points to &quot;nothing&quot;, you use <code class="docutils literal notranslate"><span class="pre">NULL</span></code> in C, which is defined as the special address 0.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// p points to nothing</span>
</pre></div>
</div>
<p>The figure below depicts the state of <code class="docutils literal notranslate"><span class="pre">p</span></code> after this assignment</p>
<figure class="align-center" id="id5">
<img alt="_images/nullptr.png" src="_images/nullptr.png" />
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">p</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, or holds the special address 0.</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="address-of-operator">
<span id="index-2"></span><h3><span class="section-number">8.1.2. </span><code class="docutils literal notranslate"><span class="pre">&amp;</span></code>: Address-of operator<a class="headerlink" href="#address-of-operator" title="Link to this heading">¶</a></h3>
<p>It is often the case that we need to obtain the address of a variable in memory in order to indirectly manipulate its contents through a pointer variable.  The address-of operator --- <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> --- is used for this purpose.  For example, the following two lines of code create an integer variable <code class="docutils literal notranslate"><span class="pre">i</span></code> initialized with contents 42, and a <em>pointer to int</em> variable <code class="docutils literal notranslate"><span class="pre">p</span></code> which is initialized with <em>the address of i</em>.  Notice that the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> goes before the variable for which we want to obtain the address.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// i directly holds the integer 42 (on the stack)</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// p holds the address of i</span>
</pre></div>
</div>
<p>Below is an example depiction of the contents of memory assuming that the variable <code class="docutils literal notranslate"><span class="pre">i</span></code> is stored at (hex) address 0x1004, and <code class="docutils literal notranslate"><span class="pre">p</span></code> is stored in the next four bytes.  (Note that this figure assumes 32 bit addressing, since <code class="docutils literal notranslate"><span class="pre">p</span></code> --- which holds a memory address --- occupies exactly 4 bytes, or 32 bits, in this diagram.)</p>
<figure class="align-center" id="id6">
<img alt="_images/addrof.png" src="_images/addrof.png" />
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">i</span></code> directly holds the value 42, and <code class="docutils literal notranslate"><span class="pre">p</span></code> holds the address
of <code class="docutils literal notranslate"><span class="pre">i</span></code>.</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="dereferencing-or-following-a-pointer">
<span id="index-3"></span><h3><span class="section-number">8.1.3. </span>Dereferencing, or &quot;following&quot; a pointer<a class="headerlink" href="#dereferencing-or-following-a-pointer" title="Link to this heading">¶</a></h3>
<p>Now that <code class="docutils literal notranslate"><span class="pre">p</span></code> &quot;points to&quot; the contents of <code class="docutils literal notranslate"><span class="pre">i</span></code>, we could indirectly modify <code class="docutils literal notranslate"><span class="pre">i</span></code>'s contents through <code class="docutils literal notranslate"><span class="pre">p</span></code>.  Essentially what we want to do is to &quot;follow&quot; (or &quot;dereference&quot;) the pointer <code class="docutils literal notranslate"><span class="pre">p</span></code> to get to the integer that its address refers to (i.e., <code class="docutils literal notranslate"><span class="pre">i</span></code>), and modify those contents.</p>
<p>The asterisk (<code class="docutils literal notranslate"><span class="pre">*</span></code>) is used as the dereference operator.  The basic syntax is: <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">&lt;pointer-variable&gt;</span></code>, which means &quot;obtain the contents of the memory address to which <code class="docutils literal notranslate"><span class="pre">&lt;pointer-variable&gt;</span></code> refers.  (Notice that the asterisk goes to the left of the pointer variable that we wish to dereference.)  We could use this syntax to increment <code class="docutils literal notranslate"><span class="pre">i</span></code> by one, indirectly through <code class="docutils literal notranslate"><span class="pre">p</span></code>, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">  </span><span class="c1">// i directly holds the integer 42</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="c1">// p holds address of i</span>
<span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// dereference p (follow pointer), add one to int to which</span>
<span class="w">             </span><span class="c1">// p points, then assign back to int to which p points</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="c1">// -&gt; will print 43</span>
</pre></div>
</div>
<p id="index-4">A canonical example for why pointers can be useful is for implementing a function that successfully swaps two values.  Here is the code to do it:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x is %d, y is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;x is %d, y is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="_images/swap.png"><img alt="_images/swap.png" src="_images/swap.png" style="width: 240.75px; height: 133.5px;" /></a>
<figcaption>
<p><span class="caption-text">Inside the <code class="docutils literal notranslate"><span class="pre">swap</span></code> function, <code class="docutils literal notranslate"><span class="pre">a</span></code> holds the address of <code class="docutils literal notranslate"><span class="pre">x</span></code> back on
<code class="docutils literal notranslate"><span class="pre">main</span></code>'s stack and <code class="docutils literal notranslate"><span class="pre">b</span></code> holds the address of <code class="docutils literal notranslate"><span class="pre">y</span></code> also on <code class="docutils literal notranslate"><span class="pre">main</span></code>'s
stack.  With pass-by-value semantics, <code class="docutils literal notranslate"><span class="pre">a</span></code> gets a <em>copy</em> of the address
of <code class="docutils literal notranslate"><span class="pre">x</span></code> (likewise, <code class="docutils literal notranslate"><span class="pre">b</span></code> gets a <em>copy</em> of the address of <code class="docutils literal notranslate"><span class="pre">y</span></code>).</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The key to this code is that we declare the <code class="docutils literal notranslate"><span class="pre">swap</span></code> function to take two <em>pointers to ints</em> as parameters (rather than the two integers themselves).  In <code class="docutils literal notranslate"><span class="pre">main</span></code>, we pass <em>copies of the addresses of x and y</em>, as shown in the figure above.  Inside <code class="docutils literal notranslate"><span class="pre">swap</span></code>, therefore, <code class="docutils literal notranslate"><span class="pre">a</span></code> holds the memory address of <code class="docutils literal notranslate"><span class="pre">x</span></code> (which is back on <code class="docutils literal notranslate"><span class="pre">main</span></code>'s stack) and <code class="docutils literal notranslate"><span class="pre">b</span></code> holds the memory address of <code class="docutils literal notranslate"><span class="pre">y</span></code> (which is also back on <code class="docutils literal notranslate"><span class="pre">main</span></code>'s stack).  Through the pointers, we indirectly modify the contents of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
<aside class="topic">
<p class="topic-title">Uninitialized pointers</p>
<p>When using pointers, there are two entities to keep track of: the pointer itself, and the memory address to which the pointer points, sometimes called the &quot;pointee&quot;.  There are three things that must be done for a pointer/pointee relationship to work correctly:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The pointer must be declared and allocated</p></li>
<li><p>The pointee must be declared and allocated</p></li>
<li><p>The pointer (1) must be initialized so that it points to the pointee (2)</p></li>
</ol>
</div></blockquote>
<p>A common error is to do (1), but not (2) or (3).  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>int *p;  // p points to ???
*p = 13; // follow p to some unknown memory location and put 13 there
</pre></div>
</div>
<p>Since C does not do any initialization for the programmer, just declaring a pointer (i.e., step 1) isn't enough for <em>using</em> a pointer.  In the above code, <code class="docutils literal notranslate"><span class="pre">p</span></code> points to some undefined memory location and the act of writing the integer 13 to that location <em>may</em> result in a crash.  The crash will likely appear to be <em>random</em>, but is entirely due to the fact that <code class="docutils literal notranslate"><span class="pre">p</span></code> was never properly initialized.</p>
<p>To fix this error, <code class="docutils literal notranslate"><span class="pre">p</span></code> must point to some actual <code class="docutils literal notranslate"><span class="pre">int</span></code> in memory, for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">q</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
<span class="nb">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">;</span> <span class="o">//</span> <span class="n">p</span> <span class="n">now</span> <span class="ow">is</span> <span class="n">initialized</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">q</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>
</pre></div>
</div>
<p>It is worth noting that the <strong class="command">scan-build</strong> (see <a class="reference internal" href="arraysstrings.html#scan-build"><span class="std std-ref">an earlier discussion on scan-build</span></a>) static analysis tool can detect problems with uninitialized pointers.</p>
</aside>
</section>
<section id="pointers-to-struct-s">
<h3><span class="section-number">8.1.4. </span>Pointers to <code class="docutils literal notranslate"><span class="pre">struct</span></code>'s<a class="headerlink" href="#pointers-to-struct-s" title="Link to this heading">¶</a></h3>
<p>Pointer variables can refer to <em>any</em> data type, including <code class="docutils literal notranslate"><span class="pre">struct</span></code> variables.  For a <code class="docutils literal notranslate"><span class="pre">struct</span></code>, the syntax for handling pointers can be a bit tricky.  To illustrate the trickiness, here is a function that exchanges (swaps) the numerator and denominator of a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fraction</span></code> (along with a bit of code to call the function):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">flip_fraction</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">).</span><span class="n">denominator</span><span class="p">;</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">).</span><span class="n">denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">).</span><span class="n">numerator</span><span class="p">;</span>
<span class="w">    </span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">).</span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="n">frac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
<span class="n">flip_fraction</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frac</span><span class="p">);</span>
</pre></div>
</div>
<p>Why do we need to use parentheses around the <code class="docutils literal notranslate"><span class="pre">(*f)</span></code>?  The reason is that the field selection operator (<code class="docutils literal notranslate"><span class="pre">.</span></code>) has higher operator precedence than the dereference operator.  Thus, a statement like <code class="docutils literal notranslate"><span class="pre">*f.numerator</span></code> simply does not work: it gets treated by the compiler as <code class="docutils literal notranslate"><span class="pre">*(f.numerator)</span></code>.  If <code class="docutils literal notranslate"><span class="pre">f</span></code> is a pointer, <code class="docutils literal notranslate"><span class="pre">f.numerator</span></code> just doesn't make any sense.  As a result, it is necessary to first dereference the struct pointer, <em>then</em> access the numerator field.</p>
<p>Because of the awkwardness of requiring the parens for <code class="docutils literal notranslate"><span class="pre">(*f).numerator</span></code> to work right, C provides an operator to access a struct field through a pointer: the <em>arrow</em> operator (<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">flip_fraction</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">denominator</span><span class="p">;</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">numerator</span><span class="p">;</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The above function using the arrow operator has <em>exactly</em> the same effect as the more unwieldy version of the <code class="docutils literal notranslate"><span class="pre">flip_fraction</span></code> function above.</p>
</section>
<section id="example-operating-system-call-with-pointers-gettimeofday">
<h3><span class="section-number">8.1.5. </span>Example operating system call with pointers: <code class="docutils literal notranslate"><span class="pre">gettimeofday</span></code><a class="headerlink" href="#example-operating-system-call-with-pointers-gettimeofday" title="Link to this heading">¶</a></h3>
<p>A standard function for getting the current system time in seconds and microseconds is to use the <code class="docutils literal notranslate"><span class="pre">gettimeofday</span></code> call.  This function is declared in the header file <code class="docutils literal notranslate"><span class="pre">&lt;sys/time.h&gt;</span></code> and has the following signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">gettimeofday</span><span class="p">(</span><span class="n">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span> <span class="n">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>where the first argument is a pointer to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timeval</span></code>, and the second argument is a pointer to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timezone</span></code>.  A <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timeval</span></code> has two fields: <code class="docutils literal notranslate"><span class="pre">tv_sec</span></code> and <code class="docutils literal notranslate"><span class="pre">tv_usec</span></code>, which contain the seconds and microseconds after the UNIX epoch (Midnight, January 1, 1970), respectively.  This function <em>fills in</em> these fields in the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timeval</span></code> passed to the function (i.e., it modifies the two fields of this struct).  <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is normally passed for the timezone argument.</p>
<p>If a programmer wants to get the current system time, a standard way to use this function is to declare a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">timeval</span></code> on the stack of the currently executing function (i.e., as a local variable), then pass the address of this struct to <code class="docutils literal notranslate"><span class="pre">gettimeofday</span></code>, as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">timeval</span><span class="w"> </span><span class="n">tv</span><span class="p">;</span>
<span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">// tv.tv_sec and tv.tv_usec now have meaningful values filled in by the gettimeofday function</span>
</pre></div>
</div>
<p>This pattern of passing the address of a stack-allocated struct is fairly common when making various system calls.</p>
<aside class="sidebar">
<p class="sidebar-title">The <code class="docutils literal notranslate"><span class="pre">const</span></code> qualifier</p>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">const</span></code> can be added to the left of a variable or parameter type to declare that the code using the variable will not change the variable.  As a practical matter, use of <code class="docutils literal notranslate"><span class="pre">const</span></code> is very sporadic in the C programming community. It does have one very handy use, which is to clarify the role of a parameter in a function prototype.  For example, in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">const</span> <span class="n">struct</span> <span class="n">fraction</span><span class="o">*</span> <span class="n">fract</span><span class="p">);</span>
</pre></div>
</div>
<p>In the <code class="docutils literal notranslate"><span class="pre">foo()</span></code> function prototype, the <code class="docutils literal notranslate"><span class="pre">const</span></code> declares that <code class="docutils literal notranslate"><span class="pre">foo()</span></code> does not intend to change the struct fraction pointee which is passed to it.  Since the fraction is passed by pointer, we could not know otherwise if <code class="docutils literal notranslate"><span class="pre">foo()</span></code> intended to change our memory or not.  Using <code class="docutils literal notranslate"><span class="pre">const</span></code>, <code class="docutils literal notranslate"><span class="pre">foo()</span></code> makes its intentions clear. Declaring this extra bit of information helps to clarify the role of the function to its implementor and caller.</p>
</aside>
</section>
</section>
<section id="advanced-c-arrays-and-pointer-arithmetic">
<h2><span class="section-number">8.2. </span>Advanced C Arrays and Pointer Arithmetic<a class="headerlink" href="#advanced-c-arrays-and-pointer-arithmetic" title="Link to this heading">¶</a></h2>
<section id="array-pointer-duality">
<h3><span class="section-number">8.2.1. </span>Array/pointer duality<a class="headerlink" href="#array-pointer-duality" title="Link to this heading">¶</a></h3>
<p>Interestingly, C compilers do not meaningfully distinguish between arrays and pointers --- a C array variable actually just holds the memory address of the beginning of the array (also referred to as the <em>base address</em> of the array).  In the following code, we illustrate the <em>duality</em> of arrays and pointers by creating 10-element <code class="docutils literal notranslate"><span class="pre">int</span></code> array (<code class="docutils literal notranslate"><span class="pre">fibarray</span></code>) and a <em>pointer</em> to an <code class="docutils literal notranslate"><span class="pre">int</span></code> (<code class="docutils literal notranslate"><span class="pre">fibptr1</span></code>).  Notice that we directly assign the array variable to an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code>, which is perfectly legal in C and nicely illustrates the duality between pointers and arrays:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">fibarray</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">55</span><span class="w"> </span><span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">fibptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibarray</span><span class="p">;</span>
</pre></div>
</div>
<p>An alternative (and somewhat more explicit) syntax for obtaining the base address of the array is to use the address-of operator with the first element of the array.  The following declaration creates yet another pointer variable that refers to the beginning of the array:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">fibptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fibarray</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="c1">// get the memory address of the first element of the array</span>
</pre></div>
</div>
<aside class="sidebar">
<p class="sidebar-title">Array names are constant pointers</p>
<p>One subtle distinction between an array and a pointer is that the array name where it is declared in the code cannot be modified.  In other words, an array name cannot be made to refer to a <em>different</em> array or pointer in memory.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">ints</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="nb">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">i</span><span class="p">;</span>

<span class="n">ints</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>      <span class="o">//</span> <span class="n">NO</span><span class="p">:</span> <span class="n">cannot</span> <span class="n">change</span> <span class="n">the</span> <span class="n">base</span> <span class="n">address</span> <span class="n">pointer</span>
<span class="n">ints</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>        <span class="o">//</span> <span class="n">NO</span>
<span class="n">ints</span> <span class="o">=</span> <span class="n">ints</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="o">//</span> <span class="n">NO</span>
<span class="n">ints</span><span class="o">++</span><span class="p">;</span>           <span class="o">//</span> <span class="n">NO</span>
</pre></div>
</div>
</aside>
</section>
<section id="pointer-arithmetic">
<h3><span class="section-number">8.2.2. </span>Pointer arithmetic<a class="headerlink" href="#pointer-arithmetic" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">+</span></code> operator can be used with pointers to access memory locations that reside at some <em>offset</em> from a pointer.   For example, say that we have the following variable: <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*i</span></code>.  <code class="docutils literal notranslate"><span class="pre">i+j</span></code> (where j is an integer, <em>not</em> a pointer) is interpreted by the compiler as <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">j</span> <span class="pre">*</span> <span class="pre">sizeof(int)</span></code>.  Thus, <code class="docutils literal notranslate"><span class="pre">i+j</span></code> yields the memory address of the jth <code class="docutils literal notranslate"><span class="pre">int</span></code> after the address <code class="docutils literal notranslate"><span class="pre">i</span></code> (where we start counting at 0, as you should expect).</p>
<p>A somewhat longer example of adding a pointer and integer together is shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">fibarray</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">34</span><span class="p">,</span><span class="w"> </span><span class="mi">55</span><span class="w"> </span><span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">fibptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibarray</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">fibptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// add 0*sizeof(int) to fibptr address, then dereference (yields the value 1)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">fibptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">  </span><span class="c1">// add 2*sizeof(int) to fibptr address, then dereference (yields the value 2)</span>
</pre></div>
</div>
<p>Again, the syntax <code class="docutils literal notranslate"><span class="pre">fibptr</span> <span class="pre">+</span> <span class="pre">2</span></code> is interpreted by the compiler as &quot;get the address of the 2nd integer following the address fibptr&quot;.</p>
<p>In fact, array indexing syntax works identically to pointer arithmetic.  As a result, square-brace indexing can be used with pointer variables.  Moreover, the nice thing about this syntax is that <em>dereferencing is automatic</em>. Continuing the code above:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibptr1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">  </span><span class="c1">// add 5*sizeof(int) to fibptr1 address,</span>
<span class="w">                    </span><span class="c1">// then dereference (automatically!) (yields 8)</span>
</pre></div>
</div>
<p>A totally bizarre implication of the way that C handles array indexing and pointers is that the array name and index value can be inverted!</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span><span class="w">   </span><span class="c1">// &quot;normal&quot; indexing</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">[</span><span class="n">array</span><span class="p">]);</span><span class="w">   </span><span class="c1">// bizarro inverted indexing, but legal and identical to previous line!</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">array</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// pointer arithmetic syntax</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">array</span><span class="p">));</span><span class="w"> </span><span class="c1">// pointer arithmetic syntax, with operands reversed</span>
</pre></div>
</div>
<p>The above code is purely an illustration --- don't write code with inverted indexing!  Although it is legal, it is a &quot;feature&quot; that makes the code harder to read since nobody writes indexes like that.</p>
</section>
</section>
<section id="dynamic-memory-allocation">
<h2><span class="section-number">8.3. </span>Dynamic memory allocation<a class="headerlink" href="#dynamic-memory-allocation" title="Link to this heading">¶</a></h2>
<p>We started this chapter by outlining how memory is organized within a single running program, or process (see <a class="reference internal" href="#addr-space"><span class="std std-ref">Process address spaces</span></a>, above).  So far, we have just used local and parameter variables, which result in <em>stack-allocated</em> memory.  In this section, we discuss how to <em>dynamically</em> allocate and deallocate blocks of memory on the heap.  C requires that a program <em>manually</em> manage heap-allocated memory through explicit allocation and deallocation.  In contrast, a language like Java only requires that a programmer explicitly allocate memory, but the language runtime handles automatic deallocation through a process called <em>garbage collection</em>.</p>
<section id="malloc-and-free">
<h3><span class="section-number">8.3.1. </span><code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code><a class="headerlink" href="#malloc-and-free" title="Link to this heading">¶</a></h3>
<p>The built-in functions <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code> are used to manually allocate and deallocate blocks of heap memory.  These functions are declared in the header file <code class="docutils literal notranslate"><span class="pre">&lt;stdlib.h&gt;</span></code> (i.e., you must <code class="docutils literal notranslate"><span class="pre">#include</span></code> this file) and work as follows:</p>
<aside class="sidebar">
<p class="sidebar-title">Pointing into the <code class="docutils literal notranslate"><span class="pre">void</span></code></p>
<p>Notice that the <code class="docutils literal notranslate"><span class="pre">malloc</span></code> function returns a &quot;pointer to void&quot; (<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>), and <code class="docutils literal notranslate"><span class="pre">free</span></code> takes a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> as a parameter. By convention in C, a pointer which does not point to any particular type is declared as <code class="docutils literal notranslate"><span class="pre">void*</span></code>. Sometimes <code class="docutils literal notranslate"><span class="pre">void*</span></code> is used to force two bodies of code not to depend on each other, since <code class="docutils literal notranslate"><span class="pre">void*</span></code> translates roughly to &quot;this points to something, but I'm not telling you (the client) the type of the pointee exactly because you do not really need to know.&quot;  That's exactly the case with <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code>:  the <code class="docutils literal notranslate"><span class="pre">malloc</span></code> function cannot possibly know what the caller wants the new memory block allocated on the heap to contain, and neither can the <code class="docutils literal notranslate"><span class="pre">free</span></code> function know what data type some memory block points to.</p>
<p>Note that a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code> cannot be dereferenced --- the compiler prevents this.  The pointer must be cast to a pointer to some concrete type in order to be dereferenced.</p>
<p>Also, interestingly, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> is usually defined as <code class="docutils literal notranslate"><span class="pre">(void*)0</span></code>.</p>
</aside>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">void*</span> <span class="pre">malloc(size_t</span> <span class="pre">size)</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">malloc</span></code> takes one parameter: the number of bytes to allocate on the heap.  It returns a &quot;generic pointer&quot; (i.e., <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>) that refers to a newly allocated block of memory on the heap.  If there is not enough memory on the heap to satisfy the request, <code class="docutils literal notranslate"><span class="pre">malloc</span></code> returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">free(void*</span> <span class="pre">block)</span></code></dt><dd><p>The mirror image of <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">free</span></code> takes a pointer to a heap block previously returned by a call to <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and returns it to the heap for re-use.  After calling <code class="docutils literal notranslate"><span class="pre">free</span></code>, the caller should not access any part of the memory block that has been returned to the heap.</p>
</dd>
</dl>
<p>Note that all of a program's memory is deallocated automatically when it exits, so a program <em>technically</em> only needs to use <code class="docutils literal notranslate"><span class="pre">free</span></code> during execution if it is important for the program to recycle its memory while it runs --- typically because it uses a lot of memory or because it runs for a long time.  However, <strong>it is always good practice to free what ever you malloc</strong>.  You should not rely on the fact that a program does not run long or that you <em>think</em> it does not use a lot of memory.</p>
<p>Here is some example code that uses <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code> to allocate a block of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fraction</span></code> records (basically an array, but not declared as an array), fill each one in with user input, invert each one, then print them all out.  Notice that each of the functions <code class="docutils literal notranslate"><span class="pre">get_fractions</span></code>, <code class="docutils literal notranslate"><span class="pre">invert_fractions</span></code>, and <code class="docutils literal notranslate"><span class="pre">print_fractions</span></code> accesses each <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fraction</span></code> in different ways: by index, and by pointer arithmetic.  Note specifically that the <code class="docutils literal notranslate"><span class="pre">invert_fractions</span></code> function modifies the <code class="docutils literal notranslate"><span class="pre">fracblock</span></code> pointer (by &quot;incrementing it by 1, which makes the pointer advance to the next <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fraction</span></code>), but since that function just gets a <em>copy</em> of the pointer to the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">fraction</span></code> this is totally ok.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="c1"> // for malloc and free</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numerator</span><span class="p">;</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">denominator</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="p">};</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="kt">void</span><span class="w"> </span><span class="nf">get_fractions</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="o">*</span><span class="n">fracblock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numfrac</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="linenos">11</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numfrac</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">12</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter numerator for fraction %d: &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">13</span><span class="w">        </span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span>
<span class="linenos">14</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="linenos">15</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Enter denominator for fraction %d: &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="linenos">16</span><span class="w">        </span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span>
<span class="linenos">17</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">        </span><span class="c1">// use array syntax to fill in numer/denom for the ith fraction</span>
<span class="linenos">20</span><span class="w">        </span><span class="n">fracblock</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numerator</span><span class="p">;</span>
<span class="linenos">21</span><span class="w">        </span><span class="n">fracblock</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">denominator</span><span class="p">;</span>
<span class="linenos">22</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">23</span><span class="p">}</span>
<span class="linenos">24</span>
<span class="linenos">25</span><span class="kt">void</span><span class="w"> </span><span class="nf">invert_fractions</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="o">*</span><span class="n">fracblock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numfrac</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">26</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numfrac</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">27</span><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fracblock</span><span class="o">-&gt;</span><span class="n">numerator</span><span class="p">;</span>
<span class="linenos">28</span><span class="w">        </span><span class="n">fracblock</span><span class="o">-&gt;</span><span class="n">numerator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fracblock</span><span class="o">-&gt;</span><span class="n">denominator</span><span class="p">;</span>
<span class="linenos">29</span><span class="w">        </span><span class="n">fracblock</span><span class="o">-&gt;</span><span class="n">denominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="w">        </span><span class="n">fracblock</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointer arithmetic:</span>
<span class="linenos">32</span><span class="w">                        </span><span class="c1">// advance the pointer by 1 struct fraction</span>
<span class="linenos">33</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">34</span><span class="p">}</span>
<span class="linenos">35</span>
<span class="linenos">36</span><span class="kt">void</span><span class="w"> </span><span class="nf">print_fractions</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="o">*</span><span class="n">fracblock</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">numfrac</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">37</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">numfrac</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">38</span><span class="w">        </span><span class="c1">// use pointer-arithmetic syntax to get numerator/denominator</span>
<span class="linenos">39</span><span class="w">        </span><span class="c1">// for each fraction</span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d: %d/%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">fracblock</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">numerator</span><span class="p">,</span><span class="w"> </span>
<span class="linenos">42</span><span class="w">                                   </span><span class="p">(</span><span class="n">fracblock</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">denominator</span><span class="p">);</span>
<span class="linenos">43</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">44</span><span class="p">}</span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">47</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
<span class="linenos">48</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;How many fractions to make? &quot;</span><span class="p">);</span>
<span class="linenos">49</span><span class="w">    </span><span class="n">fgets</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span>
<span class="linenos">50</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">numfrac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="w">    </span><span class="c1">// allocate a block of numfrac fractions from the heap</span>
<span class="linenos">53</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="w"> </span><span class="o">*</span><span class="n">fractions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fraction</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">numfrac</span><span class="p">);</span>
<span class="linenos">54</span>
<span class="linenos">55</span><span class="w">    </span><span class="c1">// call function to &quot;fill-in&quot; each fraction</span>
<span class="linenos">56</span><span class="w">    </span><span class="n">get_fractions</span><span class="p">(</span><span class="n">fractions</span><span class="p">,</span><span class="w"> </span><span class="n">numfrac</span><span class="p">);</span>
<span class="linenos">57</span><span class="w">    </span><span class="n">invert_fractions</span><span class="p">(</span><span class="n">fractions</span><span class="p">,</span><span class="w"> </span><span class="n">numfrac</span><span class="p">);</span>
<span class="linenos">58</span><span class="w">    </span><span class="n">print_fractions</span><span class="p">(</span><span class="n">fractions</span><span class="p">,</span><span class="w"> </span><span class="n">numfrac</span><span class="p">);</span>
<span class="linenos">59</span>
<span class="linenos">60</span><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">fractions</span><span class="p">);</span><span class="w"> </span><span class="c1">// return block of fraction memory to the heap</span>
<span class="linenos">61</span>
<span class="linenos">62</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="linenos">63</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="memory-leaks-and-dangling-pointers">
<h3><span class="section-number">8.3.2. </span>Memory leaks and dangling pointers<a class="headerlink" href="#memory-leaks-and-dangling-pointers" title="Link to this heading">¶</a></h3>
<p>Note that in the above example code, we have exactly 1 call to <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and exactly 1 matching call to <code class="docutils literal notranslate"><span class="pre">free</span></code>.  If you do not have a matching <code class="docutils literal notranslate"><span class="pre">free</span></code> call for each malloc, your program has a <em>memory leak</em>.  Memory leaks are especially problematic for long-running programs (e.g., web browsers are often implicated in memory leak problems <a class="footnote-reference brackets" href="#f3" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>).  The following program is one example of a pretty horrible leak: there is a <code class="docutils literal notranslate"><span class="pre">malloc</span></code> call in a loop, but no matching <code class="docutils literal notranslate"><span class="pre">free</span></code>.  Even worse, we completely lose the ability to access the memory block in the previous iteration of the loop by re-assigning to <code class="docutils literal notranslate"><span class="pre">memory_block</span></code> each time through the loop.  Note also that assigning <code class="docutils literal notranslate"><span class="pre">NULL</span></code> doesn't free a block; it simply makes a block inaccessible to the program.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BIGNUMBER</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">memory_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span><span class="w">  </span><span class="c1">// allocate a chunk on the heap</span>
<span class="w">    </span><span class="c1">// do nothing else!</span>
<span class="p">}</span>
<span class="n">memory_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">  </span><span class="c1">// doesn&#39;t free anything!  we just lost our access</span>
<span class="w">                      </span><span class="c1">// to the memory block most recently allocated, so</span>
<span class="w">                      </span><span class="c1">// we&#39;ve created a hopeless memory leak!</span>
</pre></div>
</div>
<p>A <em>dangling pointer</em> is a pointer that refers to a invalid block of memory, either to an undefined memory address or to a memory block that has already been freeed, and should thus be considered inaccessible.  For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// q is a pointer; now it just holds the same address as p</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;q is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">);</span><span class="w"> </span><span class="c1">// 42</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;p is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">// 42</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">// free p.</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;p is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">);</span><span class="w"> </span><span class="c1">// NO!  p is invalid because we just free&#39;d it!</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;q is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">q</span><span class="p">);</span><span class="w"> </span><span class="c1">// Double NO!  since we free&#39;d p, q is a &quot;dangling pointer&quot;</span>
<span class="w">                        </span><span class="c1">// since it pointed to the same memory block!</span>
</pre></div>
</div>
<aside class="topic">
<p class="topic-title"><strong class="command">scan-build</strong> and <strong class="command">valgrind</strong></p>
<p>Valgrind is a pretty excellent tool for helping to ferret out memory leaks, memory trashing, and any other type of memory corruption error that can happen in C programs.  To run a program with valgrind, you can just type <strong class="command">valgrind &lt;program&gt;</strong>.</p>
<p>There are <em>many</em> command-line options to change the behavior or output of valgrind.  Type <strong class="command">valgrind -h</strong> for help (or <strong class="command">man valgrind</strong>).  See <a class="reference external" href="http://valgrind.org">http://valgrind.org</a> for more information on this great tool.</p>
<p>Besides <strong class="command">valgrind</strong>, the <strong class="command">scan-build</strong> tool is also incredibly helpful.  It is also usually faster and with better (easier to understand) output.  See a <a class="reference internal" href="arraysstrings.html#scan-build"><span class="std std-ref">previous description of scan-build</span></a> as well as <a class="reference external" href="https://clang-analyzer.llvm.org/scan-build.html">https://clang-analyzer.llvm.org/scan-build.html</a> for more information.</p>
</aside>
</section>
<section id="advantages-and-disadvantages-of-heap-allocated-memory">
<h3><span class="section-number">8.3.3. </span>Advantages and disadvantages of heap-allocated memory<a class="headerlink" href="#advantages-and-disadvantages-of-heap-allocated-memory" title="Link to this heading">¶</a></h3>
<p>Heap-allocated memory makes it possible to create linked lists, dynamically-sized arrays and strings, and more exotic data structures such as trees, heaps, and hashtables.  Manually allocating and deallocating memory can be a pain, though.  As a result, you probably want to be strategic about whether to use stack-allocated memory (e.g., local arrays and variables) or heap-allocated memory in a program.  Here are some key advantages and disadvantages to help you consider what is right for a given situation:</p>
<section id="advantages-to-heap-allocation">
<h4><span class="section-number">8.3.3.1. </span>Advantages to heap allocation<a class="headerlink" href="#advantages-to-heap-allocation" title="Link to this heading">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><p>The size of an array, string, or some other data structure can be defined at run time.  With stack-allocated arrays, for example, you typically need to specify a &quot;reasonable upper bound&quot; for the size of the array, and somehow deal with the consequences if the size of the array is exceeded.</p></li>
<li><p>A block of memory will exist until it is explicitly deallocated with a call to <code class="docutils literal notranslate"><span class="pre">free</span></code>.  For stack-allocated memory, the memory is automatically deallocated when a function is exited, which is totally inappropriate for data structures such as linked lists.</p></li>
<li><p>You can dynamically <em>change</em> the size of the array, string, or some other data structure at run time.  There is a built-in <code class="docutils literal notranslate"><span class="pre">realloc</span></code> function that can help with this (see <strong class="command">man realloc</strong>),</p></li>
</ul>
</div></blockquote>
</section>
<section id="disadvantages-to-heap-allocation">
<h4><span class="section-number">8.3.3.2. </span>Disadvantages to heap allocation<a class="headerlink" href="#disadvantages-to-heap-allocation" title="Link to this heading">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><p>You have to remember to allocate and deallocate a data structure, and you have to get it right.  This is harder than it sounds, and when things go wrong the program will either exhibit unexpected (buggy) behavior, or crash in a ball of flames.  Debugging can be hard.</p></li>
<li><p>You have to remember to deallocate a memory block exactly once when you are done with it, and you have to get that right.  Also, harder than it looks.  For example, calling <code class="docutils literal notranslate"><span class="pre">free</span></code> on the same memory block <em>twice</em> is an error, and typically causes a crash.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="dynamic-arrays">
<h3><span class="section-number">8.3.4. </span>Dynamic Arrays<a class="headerlink" href="#dynamic-arrays" title="Link to this heading">¶</a></h3>
<p>Since arrays are just contiguous areas of bytes, you can allocate your own arrays in the heap using <code class="docutils literal notranslate"><span class="pre">malloc</span></code>.  It is also fairly straightforward to resize an array as necessary (i.e., to grow it to accommodate more data items).  The following code allocates two arrays of 1000 ints --- one in the stack the usual &quot;local&quot; way, and one in the heap using <code class="docutils literal notranslate"><span class="pre">malloc</span></code>.  Other than the different allocations, the two are syntactically similar in use.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span><span class="w"> </span><span class="c1">// allocate 1000 ints in the stack</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span><span class="w">  </span><span class="c1">// allocate 1000 ints on the heap</span>
<span class="n">a</span><span class="p">[</span><span class="mi">123</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span><span class="w">      </span><span class="c1">// just use good ol&#39; [] to access elements</span>
<span class="n">b</span><span class="p">[</span><span class="mi">123</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span><span class="w">      </span><span class="c1">// in both arrays</span>
<span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">          </span><span class="c1">// must call free on the heap-allocated array</span>
</pre></div>
</div>
<p>To grow the heap-allocated array, we could do something like the following.  (Note that the following code uses <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>, which accepts three parameters: a destination address, a source address, and the number of bytes to copy):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span><span class="w"> </span><span class="c1">// 1000 ints on the heap</span>

<span class="c1">// assume we need to grow the array</span>

<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">newarr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2000</span><span class="p">);</span><span class="w"> </span><span class="c1">// double your integer pleasure</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">newarr</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"> </span><span class="c1">// copy over contents of old array</span>
<span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span><span class="w">    </span><span class="c1">// free old array</span>
<span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newarr</span><span class="p">;</span><span class="w"> </span><span class="c1">// arr now points to new, larger block</span>
</pre></div>
</div>
</section>
<section id="c-strings-revisited">
<span id="dynamic-strings"></span><h3><span class="section-number">8.3.5. </span>C strings revisited<a class="headerlink" href="#c-strings-revisited" title="Link to this heading">¶</a></h3>
<p>Although we have used arrays of <code class="docutils literal notranslate"><span class="pre">char</span></code> to hold C strings thus far, a much more common way to declare the type of a C string is <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>.  This shouldn't be particularly surprising, since arrays and pointers are treated nearly synonymously in C.  That's not to say that stack-allocated C strings as arrays aren't useful.  Indeed, they are very commonly used.  It is, however, often necessary to copy and manipulate strings in memory, and using stack or statically allocated arrays becomes quite difficult.</p>
<p>As an example, say that we need to &quot;escape&quot; an HTML string to replace any occurrence of <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> with <code class="docutils literal notranslate"><span class="pre">&amp;lt;</span></code> (lt: &quot;less-than&quot;) and any occurrence of <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> with <code class="docutils literal notranslate"><span class="pre">&amp;gt;</span></code> (gt: &quot;greater-than&quot;).  (There are other characters that are replaced when &quot;properly&quot; escaping an HTML string; we're just focusing on these two characters in this example.)  Since the string will &quot;grow&quot; as we escape it, dynamic memory allocation has obvious benefits.  Here is the code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="linenos"> 2</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="linenos"> 3</span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="kt">int</span><span class="w"> </span><span class="nf">count_escapees</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">htmltext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">htmltext</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">htmltext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;&lt;&#39;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">htmltext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;&gt;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">            </span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">11</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">12</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="linenos">13</span><span class="p">}</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="kt">void</span><span class="w"> </span><span class="nf">doescape</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">htmltext</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">expandedtext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">16</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="linenos">17</span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">htmltext</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">18</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">htmltext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;&lt;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">19</span><span class="w">            </span><span class="n">strcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">expandedtext</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;&amp;lt;&quot;</span><span class="p">);</span>
<span class="linenos">20</span><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="linenos">21</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">htmltext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;&gt;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">22</span><span class="w">            </span><span class="n">strcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">expandedtext</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="s">&quot;&amp;gt;&quot;</span><span class="p">);</span>
<span class="linenos">23</span><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="linenos">24</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">25</span><span class="w">            </span><span class="n">expandedtext</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">htmltext</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="linenos">26</span><span class="w">            </span><span class="n">j</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">27</span><span class="w">        </span><span class="p">}</span>
<span class="linenos">28</span><span class="w">    </span><span class="p">}</span>
<span class="linenos">29</span><span class="p">}</span>
<span class="linenos">30</span>
<span class="linenos">31</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">escapehtml</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">htmltext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">32</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count_escapees</span><span class="p">(</span><span class="n">htmltext</span><span class="p">);</span>
<span class="linenos">33</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">origlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">htmltext</span><span class="p">);</span>
<span class="linenos">34</span><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">expandedlen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">origlen</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="linenos">35</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">expandedtext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">expandedlen</span><span class="p">);</span>
<span class="linenos">36</span><span class="w">    </span><span class="n">doescape</span><span class="p">(</span><span class="n">htmltext</span><span class="p">,</span><span class="w"> </span><span class="n">expandedtext</span><span class="p">);</span>
<span class="linenos">37</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">expandedtext</span><span class="p">;</span>
<span class="linenos">38</span><span class="p">}</span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">41</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">orig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&lt;a href=</span><span class="se">\&quot;</span><span class="s">badurl</span><span class="se">\&quot;</span><span class="s">&gt;a link!&lt;/a&gt;&quot;</span><span class="p">;</span>
<span class="linenos">42</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">escaped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">escapehtml</span><span class="p">(</span><span class="n">orig</span><span class="p">);</span>
<span class="linenos">43</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Original: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">orig</span><span class="p">);</span>
<span class="linenos">44</span><span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Escaped: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">escaped</span><span class="p">);</span>
<span class="linenos">45</span><span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">escaped</span><span class="p">);</span>
<span class="linenos">46</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="linenos">47</span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="linked-lists">
<h3><span class="section-number">8.3.6. </span>Linked lists<a class="headerlink" href="#linked-lists" title="Link to this heading">¶</a></h3>
<p>One of the most commonly used dynamic data structures is the <em>linked list</em>.  A standard definition of a linked list node in C, in which each node contains an integer, is as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Notice that there's something of a circular definition and usage here (i.e., inside the definition of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span></code>, we declare a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span></code> as a field).  C is perfectly happy with that circularity.</p>
<p>Manipulating nodes in a linked list generally involves allocating new nodes on the heap, linking in new nodes to the list, and/or modifying node pointers in other ways.  Here is a bit of code for adding a new node to a list by inserting in the front:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="o">*</span><span class="n">insert</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">new_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="o">*</span><span class="n">new_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="p">));</span>
<span class="w">    </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_value</span><span class="p">;</span>
<span class="w">    </span><span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">  </span><span class="c1">// next ptr of new node refers to head of old list</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">new_node</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A function to traverse a list and print each value out might look like the following.  Notice that since the <code class="docutils literal notranslate"><span class="pre">print_list</span></code> function gets a <em>copy</em> of the head of the list, it is safe to modify that pointer within the <code class="docutils literal notranslate"><span class="pre">print_list</span></code> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="w"> </span><span class="o">*</span><span class="n">head</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Node %d has the value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
<span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w">  </span><span class="c1">// advance the list pointer</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pointers-to-pointers-etc">
<span id="index-5"></span><h3><span class="section-number">8.3.7. </span>Pointers to pointers, etc.<a class="headerlink" href="#pointers-to-pointers-etc" title="Link to this heading">¶</a></h3>
<p>Some functions in the C standard library take pointers-to-pointers (&quot;double pointers&quot;), and you will likely encounter situations in which it is <em>useful</em> to make pointers-to-pointers.  One example of such a situation occurs when a function needs to allocate and initialize heap memory for a caller.  Here is an example in code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">copy_string</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">dest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!*</span><span class="n">dest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w">  </span><span class="c1">// failure!</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">strlcpy</span><span class="p">(</span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">source</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// success</span>
<span class="p">}</span>

<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="n">copy_string</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;here&#39;s a string!&quot;</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="c1">// don&#39;t forget: need to eventually free(ptr)!</span>
</pre></div>
</div>
<p>In the above code, the <code class="docutils literal notranslate"><span class="pre">copy_string</span></code> function takes a &quot;pointer to a pointer to a char&quot; as the first parameter, and a constant C string as the second parameter.  The function allocates a new block of memory using <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and copies the <code class="docutils literal notranslate"><span class="pre">source</span></code> string into a <code class="docutils literal notranslate"><span class="pre">dest</span></code> string.</p>
<p>Why can't the first parameter be <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code>?  The reason has to do with pass-by-value function parameters: since we want to <em>modify</em> what <code class="docutils literal notranslate"><span class="pre">dest</span></code> points to, we need to access that pointer indirectly or the modification only happens to a local variable.  (This is exactly the same situation we encountered with the failed <code class="docutils literal notranslate"><span class="pre">swap</span></code> function.)  Since we can indirectly access the <code class="docutils literal notranslate"><span class="pre">dest</span></code> pointer (i.e., via the pointer to the pointer), the change we make is observable to the caller of the function.</p>
<p>Outside the function, we declare a normal <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> string variable (<code class="docutils literal notranslate"><span class="pre">ptr</span></code>), then pass <em>the address of ptr</em> to the function, which creates the pointer-to-a-pointer.  When we return from the function, <code class="docutils literal notranslate"><span class="pre">ptr</span></code> has been modified (specifically, the address held in the variable <code class="docutils literal notranslate"><span class="pre">ptr</span></code> has been modified).  As a side-effect of the way this function is implemented (i.e., it uses <code class="docutils literal notranslate"><span class="pre">malloc</span></code>), we must remember to eventually call <code class="docutils literal notranslate"><span class="pre">free</span></code> on <code class="docutils literal notranslate"><span class="pre">ptr</span></code> in order to avoid a memory leak.</p>
<p class="rubric">Exercises</p>
<ol class="arabic">
<li><p>Consider the following code.  Identify exactly what is allocated on the stack and what is allocated on the heap:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="o">*</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">char</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
    <span class="n">char</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>Write a function that mimics the built-in <code class="docutils literal notranslate"><span class="pre">strdup</span></code> function.</p></li>
<li><p>Write a <code class="docutils literal notranslate"><span class="pre">clear_list</span></code> function that takes a pointer to a linked list (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span> <span class="pre">*</span></code>) and calls free for each element in the list (i.e., to completely deallocate the list).</p></li>
<li><p>Create a <code class="docutils literal notranslate"><span class="pre">clone_list</span></code> function that takes a pointer to a linked list (<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span> <span class="pre">*</span></code>) and returns a completely cloned copy of the list (i.e., there are exactly the same number of nodes in the new list, with the exactly the same values in the same order, but the old list is left totally unmodified).</p></li>
<li><p>Create a <code class="docutils literal notranslate"><span class="pre">reverse_list</span></code> function that accepts a pointer to a <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">node</span></code> and returns a pointer to the list with all elements now in reversed order.</p></li>
<li><p>Write a function that appends a new value to the end of a linked list.  The function should return a pointer to the head of the list.</p></li>
<li><p>Write new implementations of the various linked list functions we've seen and written so far but instead of having an int as the value, use a <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">*</span></code> (dynamically allocated C string).</p></li>
<li><p>Write a function that accepts the name of a text file, and allocates and returns a C string that contains the <em>entire</em> contents of the file.  (If you're familiar with the basic file I/O API of Python, this function should work like the <code class="docutils literal notranslate"><span class="pre">read()</span></code> method of a file object.)</p></li>
<li><p>Rewrite the <code class="docutils literal notranslate"><span class="pre">escapehtml</span></code> function so that it accepts a <em>pointer to a pointer to a char</em> (<code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**</span></code>), allocates a new string that contains the escaped string and <em>assigns</em> the newly allocated string to the C string pointer to by the pointer argument to the function.  For example, if the parameter is <code class="docutils literal notranslate"><span class="pre">char</span> <span class="pre">**str</span></code>, the variable <code class="docutils literal notranslate"><span class="pre">*str</span></code> refers to the C string containing the HTML text to be escaped.  When the function concludes, <code class="docutils literal notranslate"><span class="pre">*str</span></code> should <em>now</em> refer to the C string containing the escaped HTML text.  You should be sure to <code class="docutils literal notranslate"><span class="pre">free</span></code> the original unescaped C string.</p></li>
<li><p>Rewrite the <code class="docutils literal notranslate"><span class="pre">escapehtml</span></code> function so that it accepts a <em>pointer to a char</em> (not a <em>const</em> pointer), and modifies the string <em>in place</em> to escape each <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>.  You should use the built-in C library function <code class="docutils literal notranslate"><span class="pre">realloc</span></code> to dynamically reallocate heap memory allocated to the string passed into the function.  You'll need to read the <code class="docutils literal notranslate"><span class="pre">man</span></code> page for <code class="docutils literal notranslate"><span class="pre">realloc</span></code> to understand how this function works.</p></li>
<li><p>Create a couple C structs to implement a dynamically growable/shrinkable stack data structure (a stack of integers) like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">intnode</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">value</span><span class="p">;</span>
  <span class="n">struct</span> <span class="n">intnode</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
  <span class="n">struct</span> <span class="n">intnode</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
<span class="p">}</span> <span class="n">stack_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Write five functions to create, destroy/deallocate, and perform standard operations on a stack with these definitions.  Notice that the <code class="docutils literal notranslate"><span class="pre">stack_t</span></code> structure just contains a pointer to the top of the stack, and that stack is just implemented as a linked list of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">intnode</span></code>.  For the <code class="docutils literal notranslate"><span class="pre">pop</span></code> function, you can assume in your implementation that the stack is non-empty (i.e., it would be an error on the part of the user of the stack if <code class="docutils literal notranslate"><span class="pre">pop</span></code> was called on an empty stack).</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">stack_t*</span> <span class="pre">allocate_stack(void);</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">deallocate_stack(stack_t</span> <span class="pre">*);</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">empty(stack_t</span> <span class="pre">*);</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">pop(stack_t</span> <span class="pre">*);</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">push(stack_t</span> <span class="pre">*,</span> <span class="pre">int);</span></code></p></li>
</ul>
</div></blockquote>
</li>
</ol>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/High-level_programming_language">http://en.wikipedia.org/wiki/High-level_programming_language</a></p>
</aside>
<aside class="footnote brackets" id="f2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Low-level_programming_language">http://en.wikipedia.org/wiki/Low-level_programming_language</a></p>
</aside>
<aside class="footnote brackets" id="f3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>Just search for &quot;Firefox memory leak&quot; and you'll find plenty of posts not unlike the following: <a class="reference external" href="https://support.mozilla.org/en-US/questions/1006397">https://support.mozilla.org/en-US/questions/1006397</a></p>
</aside>
</aside>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">8. Pointers and more arrays</a><ul>
<li><a class="reference internal" href="#id3">8.1. Pointers</a><ul>
<li><a class="reference internal" href="#declaration-syntax">8.1.1. Declaration syntax</a></li>
<li><a class="reference internal" href="#address-of-operator">8.1.2. <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>: Address-of operator</a></li>
<li><a class="reference internal" href="#dereferencing-or-following-a-pointer">8.1.3. Dereferencing, or &quot;following&quot; a pointer</a></li>
<li><a class="reference internal" href="#pointers-to-struct-s">8.1.4. Pointers to <code class="docutils literal notranslate"><span class="pre">struct</span></code>'s</a></li>
<li><a class="reference internal" href="#example-operating-system-call-with-pointers-gettimeofday">8.1.5. Example operating system call with pointers: <code class="docutils literal notranslate"><span class="pre">gettimeofday</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-c-arrays-and-pointer-arithmetic">8.2. Advanced C Arrays and Pointer Arithmetic</a><ul>
<li><a class="reference internal" href="#array-pointer-duality">8.2.1. Array/pointer duality</a></li>
<li><a class="reference internal" href="#pointer-arithmetic">8.2.2. Pointer arithmetic</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamic-memory-allocation">8.3. Dynamic memory allocation</a><ul>
<li><a class="reference internal" href="#malloc-and-free">8.3.1. <code class="docutils literal notranslate"><span class="pre">malloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code></a></li>
<li><a class="reference internal" href="#memory-leaks-and-dangling-pointers">8.3.2. Memory leaks and dangling pointers</a></li>
<li><a class="reference internal" href="#advantages-and-disadvantages-of-heap-allocated-memory">8.3.3. Advantages and disadvantages of heap-allocated memory</a><ul>
<li><a class="reference internal" href="#advantages-to-heap-allocation">8.3.3.1. Advantages to heap allocation</a></li>
<li><a class="reference internal" href="#disadvantages-to-heap-allocation">8.3.3.2. Disadvantages to heap allocation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamic-arrays">8.3.4. Dynamic Arrays</a></li>
<li><a class="reference internal" href="#c-strings-revisited">8.3.5. C strings revisited</a></li>
<li><a class="reference internal" href="#linked-lists">8.3.6. Linked lists</a></li>
<li><a class="reference internal" href="#pointers-to-pointers-etc">8.3.7. Pointers to pointers, etc.</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="functions.html"
                          title="previous chapter"><span class="section-number">7. </span>Functions</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="programstructure.html"
                          title="next chapter"><span class="section-number">9. </span>Program structure and compilation</a></p>
  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><h4>Got issues?</h4>
  <p>If you find a bug or have a suggestion for improvement, please <a href="https://github.com/jsommers/cbook/issues">report it</a>.</p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="programstructure.html" title="9. Program structure and compilation"
             >next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="7. Functions"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">The Book of C (version 2022.08)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><span class="section-number">8. </span>Pointers and more arrays</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2014-2022, Joel Sommers.
    </div>
  </body>
</html>