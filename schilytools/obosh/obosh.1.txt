sh(1)				 User Commands				 sh(1)

NAME
       sh, obosh, jsh - standard and job control shell and command interpreter

SYNOPSIS
       /usr/bin/sh   [-acefhikmnprstuvxP] [argument]...


       /usr/bin/obosh [-acefhikmnprstuvxP] [argument]...


       /usr/bin/jsh  [-acefhikmnprstuvxP] [argument]...


DESCRIPTION
       The /usr/bin/sh utility is a command programming language that executes
       commands read from a terminal or a file.

       The name obosh permits to call this implementaton even when /usr/bin/sh
       has been linked to another shell.

       The jsh utility is an interface to the shell that provides all of the
       functionality of sh and enables job control (see Job Control section
       below).	Job control may also be enabled by calling the shell via the
       standard name and then calling set -m.


       Arguments to the shell are listed in the Invocation section below.

   Definitions
       A blank is a tab or a space. A name is a sequence of ASCII letters,
       digits, or underscores, beginning with a letter or an underscore. A
       parameter is a name, a digit, or any of the characters *, @, #, ?, -,
       $, and !.


   Invocation
       If the shell is invoked through exec(2) and the first character of
       argument zero is -, commands are initially read from /etc/profile and
       from $HOME/.profile, if such files exist.  Thereafter, commands are
       read as described below, which is also the case when the shell is
       invoked as /usr/bin/sh.


OPTIONS
       The options below are interpreted by the shell on invocation only.
       Note: Unless the -c or -s option is specified, the first argument is
       assumed to be the name of a file containing commands, and the remaining
       arguments are passed as positional parameters to that command file:

       -c string   If the -c option is present commands are read from string.
		   The remaining arguments become positional parameters
		   starting at $0.

       -i	   If the -i option is present or if the shell input and
		   output are attached to a terminal, this shell is
		   interactive.	 In this case, TERMINATE is ignored (so that
		   kill 0 does not kill an interactive shell) and INTERRUPT is
		   caught and ignored (so that wait is interruptible). In all
		   cases, QUIT is ignored by the shell.

       -p	   If the -p option is present, the shell does not set the
		   effective user and group IDs to the real user and group
		   IDs.

       -r	   If the -r option is present the shell is a restricted shell
		   (see rsh(1M)).

       -s	   If the -s option is present or if no arguments remain,
		   commands are read from the standard input. Any remaining
		   arguments specify the positional parameters. Shell output
		   (except for Special Commands) is written to file descriptor
		   2.

       -version	   Print the current Bourne Shell version and exit.

       Using + rather than - causes the related options to be turned off.  The
       remaining options and arguments are described under the set command
       below.


USAGE
   Commands
       A simple-command is a sequence of non-blank words separated by blanks.
       The first word specifies the name of the command to be executed. Except
       as specified below, the remaining words are passed as arguments to the
       invoked command. The command name is passed as argument 0 (see
       exec(2)).  The value of a simple-command is its exit status if it
       terminates normally, or (octal) 200+status if it terminates abnormally.
       See signal.h(3HEAD) for a list of status values.


       A pipeline is a sequence of one or more commands separated by |.	 The
       standard output of each command but the last is connected by a pipe(2)
       to the standard input of the next command.  Each command is run as a
       separate process. The shell waits for the last command to terminate.
       The exit status of a pipeline is the exit status of the last command in
       the pipeline.


       A list is a sequence of one or more pipelines separated by ;, &, &&, or
       ||, and optionally terminated by ; or &.	 Of these four symbols, ; and
       & have equal precedence, which is lower than that of && and ||.	The
       symbols && and || also have equal precedence. A semicolon (;) causes
       sequential execution of the preceding pipeline, that is, the shell
       waits for the pipeline to finish before executing any commands
       following the semicolon. An ampersand (&) causes asynchronous execution
       of the preceding pipeline, that is, the shell does not wait for that
       pipeline to finish. The symbol && (||) causes the list following it to
       be executed only if the preceding pipeline returns a zero (non-zero)
       exit status. An arbitrary number of newlines can appear in a list,
       instead of semicolons, to delimit commands.


       A command is either a simple-command or one of the following.  Unless
       otherwise stated, the value returned by a command is that of the last
       simple-command executed in the command.


       for name [ in word ... ] do list done
	      Each time a for command is executed, name is set to the next
	      word taken from the in word list. If in word ... is omitted,
	      then the for command executes the do list once for each
	      positional parameter that is set (see Parameter Substitution
	      section below). Execution ends when there are no more words in
	      the list.


       case word in [ pattern [ | pattern ] ) list ;; ] ...  esac
	      A case command executes the list associated with the first
	      pattern that matches word.  The form of the patterns is the same
	      as that used for file-name generation (see File Name Generation
	      section), except that a slash, a leading dot, or a dot
	      immediately following a slash need not be matched explicitly.

       if list then list [ elif list then list ] ... [ else list ] fi
	      The list following if is executed and, if it returns a zero exit
	      status, the list following the first then is executed.
	      Otherwise, the list following elif is executed and, if its value
	      is zero, the list following the next then is executed. Failing
	      that, the else list is executed. If no else list or then list is
	      executed, then the if command returns a zero exit status.

       while list do list done
       until list do list done
	      A while command repeatedly executes the while list and, if the
	      exit status of the last command in the list is zero, executes
	      the do list; otherwise the loop terminates. If no commands in
	      the do list are executed, then the while command returns a zero
	      exit status; until can be used in place of while to negate the
	      loop termination test.

       (list)
	      Execute list in a sub-shell.

       { list;}
	      list is executed in the current (that is, parent) shell. The {
	      must be followed by a space.

       name () { list;}
	      Define a function which is referenced by name.  The body of the
	      function is the list of commands between { and }.	 The { must be
	      followed by a space. Execution of functions is described below
	      (see Execution section). The { and } are unnecessary if the body
	      of the function is a command as defined above, under Commands.

       The following words are only recognized as the first word of a command
       and when not quoted:


	 if	  then	   else	   elif	   fi	   case	   esac
	 for	  while	   until   do	   done	   {   }

   Comments Lines
       A word beginning with # causes that word and all the following
       characters up to a newline to be ignored.


   Command Substitution
       The shell reads commands from the string between two grave accents (``)
       and the standard output from these commands can be used as all or part
       of a word. Trailing newlines from the standard output are removed.


       No interpretation is done on the string before the string is read,
       except to remove backslashes (\) are used to escape other characters.

       Backslashes can be used to escape a grave accent (`) or another
       backslash (\) and are removed before the command string is read.
       Escaping grave accents allows nested command substitution.  If the
       command substitution lies within a pair of double quotes (" ...` ...`
       ... "), a backslash used to escape a double quote (\") is removed.
       Otherwise, it is left intact.


       If a backslash is used to escape a newline character (\newline), both
       the backslash and the newline are removed (see the later section on
       Quoting).  In addition, backslashes used to escape dollar signs (\$)
       are removed. Since no parameter substitution is done on the command
       string before it is read, inserting a backslash to escape a dollar sign
       has no effect. Backslashes that precede characters other than \, `, ",
       newline, and $ are left intact when the command string is read.

       Command substitution allows the output of a command to be substituted
       in place of the command name itself. Command substitution occurs when
       the command is enclosed as follows:

	 `command`

       The shell expands the command substitution by executing command in a
       subshell environment and replacing the command substitution (the text
       of command plus the enclosing backquotes) with the standard output of
       the command, removing sequences of one or more newline characters at
       the end of the substitution. Embedded newline characters before the end
       of the output is not be removed; however, they can be treated as field
       delimiters and eliminated during field splitting, depending on the
       value of IFS and quoting that is in effect.

       Any valid shell script can be used for command.

       The results of command substitution are not field splitting and
       pathname expansion processed for further tilde expansion, parameter
       expansion, command substitution or arithmetic  expansion. If a command
       substitution occurs inside double-quotes, it is not be performed on the
       results of the substitution.


   Parameter Substitution
       The character $ is used to introduce substitutable parameters.  There
       are two types of parameters, positional and keyword. If parameter is a
       digit, it is a positional parameter. Positional parameters can be
       assigned values by set.	Keyword parameters (also known as variables)
       can be assigned values by writing:


       name=value [ name=value ] ...


       The evaluation of the assignments is done from the left to the right in
       this shell.

       Pattern-matching is not performed on value.  There cannot be a function
       and a variable with the same name.

       ${parameter}		The value, if any, of the parameter is
				substituted. The braces are required only when
				parameter is followed by a letter, digit, or
				underscore that is not to be interpreted as
				part of its name, or when the parameter name
				contains a dot (.).  If parameter is * or @,
				all the positional parameters, starting with
				$1, are substituted (separated by spaces).
				Parameter $0 is set from argument zero when
				the shell is invoked.


       ${parameter:-word}	Use Default Values.  If parameter is unset or
				null, the expansion of word is substituted;
				otherwise, the value of parameter is
				substituted.


       ${parameter-word}	Use Default Values.  If parameter is unset,
				the expansion of word is substituted;
				otherwise, the value of parameter is
				substituted.


       ${parameter:=word}	Assign Default Values.	If parameter is unset
				or null, the expansion of word is assigned to
				parameter.  In all cases, the final value of
				parameter is substituted. Only variables, not
				positional parameters or special parameters,
				can be assigned in this way.


       ${parameter=word}	Assign Default Values.	If parameter is unset,
				the expansion of word is assigned to
				parameter.  In all cases, the final value of
				parameter is substituted. Only variables, not
				positional parameters or special parameters,
				can be assigned in this way.


       ${parameter:?word}	Indicate Error if Null or Unset.  If parameter
				is set and is non-null, substitute its value;
				otherwise, print word and exit from the shell.
				If word is omitted, the message "parameter
				null or not set" is printed.


       ${parameter?word}	Indicate Error if Null or Unset.  If parameter
				is set, substitute its value; otherwise, print
				word and exit from the shell. If word is
				omitted, the message "parameter null or not
				set" is printed.


       ${parameter:+word}	Use Alternative Value.	If parameter is set
				and is non-null, substitute word; otherwise
				substitute nothing.


       ${parameter+word}	Use Alternative Value.	If parameter is set,
				substitute word; otherwise substitute nothing.


       If the colon (:) is omitted from the above expressions, the shell only
       checks whether parameter is set or not.	The following table summarizes
       the effect of the <colon>:

			  | parameter nonnull |	 parameter null	 | parameter unset
       -------------------+-------------------+------------------+-----------------
       ${parameter:-word} | subst. parameter  | subst. word	 | subst. word
       -------------------+-------------------+------------------+-----------------
       ${parameter-word}  | subst. parameter  | subst. null	 | subst. word
       -------------------+-------------------+------------------+-----------------
       ${parameter:=word} | subst. parameter  | assign word	 | assign word
       -------------------+-------------------+------------------+-----------------
       ${parameter=word}  | subst. parameter  | subst. null	 | assign word
       -------------------+-------------------+------------------+-----------------
       ${parameter:	  | word}	      | subst. parameter | error, exit
       -------------------+-------------------+------------------+-----------------
       ${parameter	  | word}	      | subst. parameter | subst. null
       -------------------+-------------------+------------------+-----------------
       ${parameter:+word} | subst. word	      | subst. null	 | subst. null
       -------------------+-------------------+------------------+-----------------
       ${parameter+word}  | subst. word	      | subst. word	 | subst. null
       -------------------+-------------------+------------------+-----------------

       In all cases shown with "assign", parameter is assigned that value,
       which also replaces the expression.


       In the above, word is not evaluated unless it is to be used as the
       substituted string, so that, in the following example, pwd is executed
       only if d is not set or is null:

	 echo  ${d:-`pwd`}



       The following parameters are automatically set by the shell.

       #       The number of positional parameters in decimal.

       n       The n-th positional parameter.  The parameter name n is in the
	       range from 1 to $#.

       0       Parameter $0 is set from argument zero when the shell is
	       invoked.	 If running a script, $0 is the name of the script.

       *       All positional parameters starting from $1.  "$*" expands to
	       one argument that contains all positional parameters separated
	       by a space.

       @       All positional parameters starting from $1.  "$@" expands to $#
	       arguments.

       -       Flags supplied to the shell on invocation or by the set
	       command.

       ?       The decimal value returned by the last synchronously executed
	       command.	 Only the low 8 bits of the exit code from the command
	       are visible.  If the command was killed by a signal, the
	       returned value is 128 + the signal number.

       $       The decimal process number of this shell.  In a subshell, this
	       still expands to the same value as that of the current invoked
	       shell.

       !       The process number of the last background command invoked.


       The following parameters are used by the shell. The parameters in this
       section are also referred to as environment variables.

       HOME	    The default argument (home directory) for the cd command,
		    set to the user's login directory by login(1) from the
		    password file (see passwd(4)).


       PATH	    The search path for commands (see Execution section
		    below).  If PATH is not set, it defaults to /usr/bin:.


       CDPATH	    The search path for the cd command.


       MAIL	    If this parameter is set to the name of a mail file and
		    the MAILPATH parameter is not set, the shell informs the
		    user of the arrival of mail in the specified file.


       MAILCHECK    This parameter specifies how often (in seconds) the shell
		    checks for the arrival of mail in the files specified by
		    the MAILPATH or MAIL parameters. The default value is 600
		    seconds (10 minutes). If set to 0, the shell checks before
		    each prompt.


       MAILPATH	    A colon-separated list of file names. If this parameter is
		    set, the shell informs the user of the arrival of mail in
		    any of the specified files. Each file name can be followed
		    by % and a message that is e printed when the modification
		    time changes. The default message is, you have mail.


       OPTARG	    This variable is used by getopts to store the argument if
		    an option is using arguments.


       OPTIND	    This variable is used by getopts as the index of the next
		    argument to be processed.


       PS1	    Primary prompt string, by default "$ " for normal users
		    and "privileged users.


       PS2	    Secondary prompt string, by default "> ".


       REPLY	    This variable is set by the select statement and by the
		    read special builtin command when no arguments are
		    supplied.


       IFS	    Internal field separators, normally space, tab, and
		    newline (see Blank Interpretation section).


       SHACCT	    If this parameter is set to the name of a file writable by
		    the user, the shell writes an accounting record in the
		    file for each shell procedure executed.


       SHELL	    When the shell is invoked, it scans the environment (see
		    Environment section below) for this name.  If the past
		    pathname component equals to rsh or rbosh, the shell is
		    swichted into a restricted shell.


       SYSV3	    When the SYSV3 Environment is set, the builtin echo
		    command is switched into SYSV3 mode and supports escape
		    sequences and the BSD -n option to suppress the newline
		    character at the end of the output.



       See environ(5) for descriptions of the following environment variables
       that affect the execution of sh: LANG, LC_ALL, LC_CTYPE , LC_MESSAGES
       and LC_NUMERIC.


       The shell gives default values to PATH, PS1, PS2, MAILCHECK, OPTIND,
       and IFS.	 Default values for HOME and MAIL are set by login(1).	For
       security reasons, the value for IFS is never imported from the
       environment.


   Blank Interpretation
       After parameter and command substitution, the results of substitution
       are scanned for internal field separator characters (those found in
       IFS) and split into distinct arguments where such characters are found.
       Explicit null arguments ("" or '') are retained. Implicit null
       arguments (those resulting from parameters that have no values) are
       removed.

       The IFS parameter is applied to any unquoted word. Thus.

	      IFS=X
	      echoXfoo

       executes the `echo' command with the argument `foo'.


   Input/Output Redirection
       A command's input and output can be redirected using a special notation
       interpreted by the shell. The following can appear anywhere in a
       simple-command or can precede or follow a command and are not passed on
       as arguments to the invoked command.  Note: Parameter and command
       substitution occurs before word or digit is used.

       <word	       Use file word as standard input (file descriptor 0).


       >word	       Use file word as standard output (file descriptor 1).
		       If the file does not exist, it is created.  If the file
		       exists, and the noclobber option is on, this causes an
		       error.  Otherwise, it is truncated to zero length.


       >>word	       Use file word as standard output. If the file exists,
		       output is appended to it by first seeking to the EOF.
		       Otherwise, the file is created.


       <>word	       Open file word for reading and writing as standard
		       input.


       <<[-]word       After parameter and command substitution is done on
		       word, the shell input is read up to the first line that
		       literally matches the resulting word, or to an EOF.
		       If, however, the hyphen (-) is appended to <<:

			   1.	  leading tabs are stripped from word before
				  the shell input is read (but after parameter
				  and command substitution is done on word);

			   2.	  leading tabs are stripped from the shell
				  input as it is read and before each line is
				  compared with word; and

			   3.	  shell input is read up to the first line
				  that literally matches the resulting word,
				  or to an EOF.
		       If any character of word is quoted (see Quoting section
		       later), no additional processing is done to the shell
		       input. If no characters of word are quoted:

			   1.	  parameter and command substitution occurs;

			   2.	  (escaped) \newlines are removed; and

			   3.	  \ must be used to quote the characters \, $,
				  and `.
		       The resulting document becomes the standard input.


       <&digit	       Use the file associated with file descriptor digit as
		       standard input.	Similarly for the standard output
		       using >&digit.


       <&-	       The standard input is closed. Similarly for the
		       standard output using >&-.



       If any of the above is preceded by a digit, the file descriptor which
       is associated with the file is that specified by the digit (instead of
       the default 0 or 1).  For example:

	 ... 2>&1




       associates file descriptor 2 with the file currently associated with
       file descriptor 1.


       The order in which redirections are specified is significant. The shell
       evaluates redirections left-to-right. For example:

	 ... 1>xxx 2>&1




       first associates file descriptor 1 with file xxx.  It associates file
       descriptor 2 with the file associated with file descriptor 1 (that is,
       xxx).  If the order of redirections were reversed, file descriptor 2
       would be associated with the terminal (assuming file descriptor 1 had
       been) and file descriptor 1 would be associated with file xxx.


       Using the terminology introduced on the first page, under Commands, if
       a command is composed of several simple commands, redirection is
       evaluated for the entire command before it is evaluated for each simple
       command.	 That is, the shell evaluates redirection for the entire list,
       then each pipeline within the list, then each command within each
       pipeline, then each list within each command.


       If a command is followed by & and job control (see set -m) is not
       active, the default standard input for the command is the empty file,
       /dev/null.  Otherwise, the environment for the execution of a command
       contains the file descriptors of the invoking shell as modified by
       input/output specifications.

   File Name Generation
       Before a command is executed, each command word is scanned for the
       characters *, ?, and [.	If one of these characters appears the word is
       regarded as a pattern.  The word is replaced with alphabetically sorted
       file names that match the pattern. If no file name is found that
       matches the pattern, the word is left unchanged. The character .	 at
       the start of a file name or immediately following a /, as well as the
       character / itself, must be matched explicitly.

       *	    Matches any string, including the null string.


       ?	    Matches any single character.


       [...]	    Matches any one of the enclosed characters. A pair of
		    characters separated by - matches any character lexically
		    between the pair, inclusive.  If the first character
		    following the opening [ is a !, any character not enclosed
		    is matched.



       Notice that all quoted characters (see below) must be matched
       explicitly in a filename.

   Quoting
       The following characters have a special meaning to the shell and cause
       termination of a word unless quoted:


       ;  &  (	)  |  ^	 <  >  newline	space  tab


       A character can be quoted (that is, made to stand for itself) by
       preceding it with a backslash (\) or inserting it between a pair of
       quote marks ('' or ""). During processing, the shell can quote certain
       characters to prevent them from taking on a special meaning.
       Backslashes used to quote a single character are removed from the word
       before the command is executed. The pair \newline is removed from a
       word before command and parameter substitution.


       All characters enclosed between a pair of single quote marks (''),
       except a single quote, are quoted by the shell. Backslash has no
       special meaning inside a pair of single quotes. A single quote can be
       quoted inside a pair of double quote marks (for example, "'"), but a
       single quote can not be quoted inside a pair of single quotes.


       Inside a pair of double quote marks (""), parameter and command
       substitution occurs and the shell quotes the results to avoid blank
       interpretation and file name generation. If $* is within a pair of
       double quotes, the positional parameters are substituted and quoted,
       separated by quoted spaces ("$1 $2 ..."). However, if $@ is within a
       pair of double quotes, the positional parameters are substituted and
       quoted, separated by unquoted spaces ("$1""$2"  ... ).  \ quotes the
       characters \, `, , (comma), and $.  The pair \newline is removed before
       parameter and command substitution. If a backslash precedes characters
       other than \, `, , (comma), $, and newline, then the backslash itself
       is quoted by the shell.

   Prompting
       When used interactively, the shell prompts with the value of PS1 before
       reading a command. If at any time a newline is typed and further input
       is needed to complete a command, the secondary prompt (that is, the
       value of PS2) is issued.

   Environment
       The environment (see environ(5)) is a list of name-value pairs that is
       passed to an executed program in the same way as a normal argument
       list. The shell interacts with the environment in several ways. On
       invocation, the shell scans the environment and creates a parameter for
       each name found, giving it the corresponding value. If the user
       modifies the value of any of these parameters or creates new
       parameters, none of these affects the environment unless the export
       command is used to bind the shell's parameter to the environment (see
       also set -a).  A parameter can be removed from the environment with the
       unset command.  The environment seen by any executed command is thus
       composed of any unmodified name-value pairs originally inherited by the
       shell, minus any pairs removed by unset, plus any modifications or
       additions, all of which must be noted in export commands.


       The environment for any simple-command can be augmented by prefixing it
       with one or more assignments to parameters. Thus:

	 TERM=450 command




       and

	 (export TERM; TERM=450; command)




       are equivalent as far as the execution of command is concerned if
       command is not a Special Command. If command is a Special Command, then

	 TERM=450 command




       modifies the TERM variable in the current shell.


       If the -k flag is set, all keyword arguments are placed in the
       environment, even if they occur after the command name. The following
       example first prints a=b c and c:

	 echo a=b  c

	 a=b  c

	 set  -k

	 echo a=b  c

	 c



   Signals
       The INTERRUPT and QUIT signals for an invoked command are ignored if
       the command is followed by &.  Otherwise, signals have the values
       inherited by the shell from its parent, with the exception of signal 11
       (but see also the trap command below).

   Execution
       Each time a command is executed, the command substitution, parameter
       substitution, blank interpretation, input/output redirection, and
       filename generation listed above are carried out. If the command name
       matches the name of a defined function, the function is executed in the
       shell process (note how this differs from the execution of shell script
       files, which require a sub-shell for invocation). If the command name
       does not match the name of a defined function, but matches one of the
       Special Commands listed below, it is executed in the shell process.


       The positional parameters $1, $2, ... are set to the arguments of the
       function. If the command name matches neither a Special Command nor the
       name of a defined function, a new process is created and an attempt is
       made to execute the command via exec(2).


       The shell parameter PATH defines the search path for the directory
       containing the command. Alternative directory names are separated by a
       colon (:).  The default path is /usr/bin:.  The current directory is
       specified by a null path name, which can appear immediately after the
       equal sign, between two colon delimiters anywhere in the path list, or
       at the end of the path list. If the command name contains a / the
       search path is not used. Otherwise, each directory in the path is
       searched for an executable file. If the file has execute permission but
       is not an a.out file, it is assumed to be a file containing shell
       commands. A sub-shell is spawned to read it. A parenthesized command is
       also executed in a sub-shell.


       The location in the search path where a command was found is remembered
       by the shell (to help avoid unnecessary execs later). If the command
       was found in a relative directory, its location must be re-determined
       whenever the current directory changes. The shell forgets all
       remembered locations whenever the PATH variable is changed or the hash
       -r command is executed (see below).

   Built-in Commands
       The following commands are executed in the shell process.  Input/output
       redirection is permitted for these commands. File descriptor 1 is the
       default output location. When Job Control is enabled, additional
       Built-in Commands are added to the shell's environment (see Job Control
       section below).

       Commands marked with a + are treated specially in the following ways:

	      1.     Parameter assignments that precede a special builtin
		     command affect the shell itself.

	      2.     I/O redirections are processed after variable assignments
		     for variables that precede the builtin command.

	      3.     Errors may cause a script that contains them to abort.

       In this version of sh, parameter assignments that precede any builtin
       command affect the shell itself.

       + :

	   No effect; the command does nothing. A zero exit code is returned.


       + . filename

	   Read and execute commands from filename and return. The search path
	   specified by PATH is used to find the directory containing
	   filename.


       [ [expr] ]

	   See test builtin below.


       bg [%jobid ...]

	   When Job Control is enabled, the bg command is added to the user's
	   environment to manipulate jobs. Resumes the execution of a stopped
	   job in the background. If %jobid is omitted the current job is
	   assumed.  (See Job Control section below for more detail.)


       + break [ n ]

	   Exit from the enclosing for or while loop, if any. If n is
	   specified, break n levels.


       cd [ argument ]

	   Change the current directory to argument.  If arg is - the
	   directory is changed to the previous directory.  The shell
	   parameter HOME is the default argument.  The shell parameter CDPATH
	   defines the search path for the directory containing argument.
	   Alternative directory names are separated by a colon (:).  The
	   default path is <null> (specifying the current directory).  Note:
	   The current directory is specified by a null path name, which can
	   appear immediately after the equal sign or between the colon
	   delimiters anywhere else in the path list. If argument begins with
	   a / the search path is not used. Otherwise, each directory in the
	   path is searched for argument.


       chdir [ dir ]

	   chdir changes the shell's working directory to directory dir.  If
	   no argument is given, change to the home directory of the user. If
	   dir is a relative pathname not found in the current directory,
	   check for it in those directories listed in the CDPATH variable. If
	   dir is the name of a shell variable whose value starts with a /,
	   change to the directory named by that value.


       + continue [ n ]

	   Resume the next iteration of the enclosing for or while loop. If n
	   is specified, resume at the n-th enclosing loop.


       echo [ arguments ... ]

	   The words in arguments are written to the shell's standard output,
	   separated by space characters. See echo(1) for fuller usage and
	   description.

	   If /usr/ucb appears before any other system directory in PATH and
	   the first argument is -n, echo does not print a final new-line and
	   does not interpret backslashed escape characters.  Otherwise, -n is
	   treated as a normal argument.  If the $SYSV3 variable is set in the
	   initial environment passed to the shell, the -n argument is also
	   interpreted, but escape sequences are processed as usual.

	   The following character sequences are recognized within any of the
	   arguments:

	   \a	  Alert character.
	   \b	  Backspace.
	   \c	  Print line without new-line. All characters following the \c
		  in the argument are ignored.
	   \f	  Form-feed.
	   \n	  New-line.
	   \r	  Carriage return.
	   \t	  Tab.
	   \v	  Vertical tab.
	   \\	  Backslash.
	   \0n	  Where n is the 8-bit character whose ASCII code is the 1-,
		  2- or 3-digit octal number representing that character.


       + eval [ argument ... ]

	   The arguments are read as input to the shell and the resulting
	   command(s) executed.


       + exec [-a name] [ argument ... ]

	   The command specified by the arguments is executed in place of this
	   shell without creating a new process. Input/output arguments can
	   appear and, if no other arguments are given, cause the shell
	   input/output to be modified.	 The -a option causes name rather than
	   the first arg, to become argv[0] for the new process.


       + exit [ n ]

	   Causes the calling shell or shell script to exit with the exit
	   status specified by n.  If n is omitted the exit status is that of
	   the last command executed (an EOF also causes the shell to exit.)


       + export [ name ... ]

	   The given names are marked for automatic export to the environment
	   of subsequently executed commands. If no arguments are given,
	   variable names that have been marked for export during the current
	   shell's execution are listed.  (Variable names exported from a
	   parent shell are listed only if they have been exported again
	   during the current shell's execution.) Function names are not
	   exported.


       fg [%jobid ...]

	   When Job Control is enabled, the fg command is added to the user's
	   environment to manipulate jobs. This command resumes the execution
	   of a stopped job in the foreground and also moves an executing
	   background job into the foreground. If %jobid is omitted, the
	   current job is assumed. (See Job Control section below for more
	   detail.)


       getopts optstring name [arg...]

	   Use in shell scripts to support command syntax standards (see
	   Intro(1)).  This command parses positional parameters and checks
	   for legal options. See getoptcvt(1) for usage and description.

	   The getopts builtin command parses its args or the global args of
	   the current shell, using optstring as option definition.  Each time
	   it is invoked, it places the next option character into the
	   variable name and the index of the next argument to be processed
	   into OPTIND.	 Whenever the shell or a shell script is invoked,
	   OPTIND is initialized to 1.	Calling getopts repeatedly causes one
	   option to be retrieved per call.

	   When an option requires an option-argument, getopts places it in
	   the shell variable OPTARG.

	   If an illegal option is encountered, ?  is placed in name.  If
	   optstring starts with a colon and a required option-argument is
	   missing, a colon is placed in name.

	   When the end of options is encountered, getopts exits with a non-
	   zero exit status.  The special arg -- can be used to delimit the
	   end of the options.

	   optstring must contain the option letters the command using getopts
	   recognizes. If a letter is followed by a colon, the option is
	   expected to have an argument, or group of arguments, which must be
	   separated from it by white space.

	   Unless optstring starts with a colon, getopts prints an error
	   message on the standard error when it encounters an option letter
	   not included in optstring.

	   getopts supports one or more long options as an alias to a short
	   option.  You must enclose each long option equivalent in
	   parentheses, as follows:

	     getopts "f:(file)(input-file)o:(output-file)"

	   In the above example, both --file and --input-file are the
	   equivalent of -f, and --output-file is the equivalent of -o.

	   If optstring starts with "()", getopts supports long options with a
	   single dash.	 Long options with a single dash have been introduced
	   with Multics and appeared on UNIX around 1980, see e.g.  kill(1).

	   If a long name argument follows a single dash and cannot be
	   identified as a long option, it is retried as a combination of
	   single character letters.  To suppress error messages, the optional
	   initial colon in optstring must precede the "()":

	     getopts ":()f:(file)(input-file)o:(output-file)"

	   In the above example, -file, --file, -input-file, --input-file are
	   the equivalent of -f, and -output-file and --output-file is the
	   equivalent of -o.  Error messages from getopts are suppressed and a
	   colon is placed in name when an option argument for an option like
	   -f is missing.


       hash [ -r ] [ name ... ]

	   For each name, the location in the search path of the command
	   specified by name is determined and remembered by the shell. The -r
	   option causes the shell to forget all remembered locations. If no
	   arguments are given, information about remembered commands is
	   presented.  Hits is the number of times a command has been invoked
	   by the shell process.  Cost is a measure of the work required to
	   locate a command in the search path. If a command is found in a
	   "relative" directory in the search path, after changing to that
	   directory, the stored location of that command is recalculated.
	   Commands for which this are done are indicated by an asterisk (*)
	   adjacent to the hits information.  Cost is incremented when the
	   recalculation is done.


       jobs [-p|-l] [%jobid ...]
       jobs -x command [arguments]

	   Reports all jobs that are stopped or executing in the background.
	   If %jobid is omitted, all jobs that are stopped or running in the
	   background are reported. (See Job Control section below for more
	   detail.)


       kill [ -sig ] [ pid ] [ %job ] ...
       kill -l

	   Sends either the TERM (terminate) signal or the specified signal to
	   the specified jobs or processes. Signals are either given by number
	   or by names (as given in signal.h(3HEAD) stripped of the prefix
	   "SIG" with the exception that SIGCHD is named CHLD).	 If the signal
	   being sent is TERM (terminate) or HUP (hangup), then the job or
	   process is sent a CONT (continue) signal if it is stopped. The
	   argument job can be the process id of a process that is not a
	   member of one of the active jobs. See Job Control section below for
	   a description of the format of job.	In the second form, kill -l,
	   the signal numbers and names are listed.  (See kill(1)).


       login [ argument ... ]

	   Equivalent to `exec login argument....' See login(1) for usage and
	   description.


       newgrp [ argument ]

	   Equivalent to exec newgrp argument.	See newgrp(1) for usage and
	   description.


       pwd

	   Print the current working directory as absolute pathname that does
	   not contain the filenames dot (.) or dot-dot (..).  See pwd(1) for
	   usage and description.


       read [ name ... ]

	   One line is read from the standard input and, using the internal
	   field separator, IFS (normally space or tab), to delimit word
	   boundaries, the first word is assigned to the first name, the
	   second word to the second name, and so forth, with leftover words
	   assigned to the last name.  Lines can be continued using \newline.
	   Characters other than newline can be quoted by preceding them with
	   a backslash. These backslashes are removed before words are
	   assigned to names, and no interpretation is done on the character
	   that follows the backslash.	If The exit code is 0, unless an EOF
	   is encountered.


       + readonly [ name ... ]

	   The given names are marked readonly and the values of the these
	   names can not be changed by subsequent assignment. If no arguments
	   are given, a list of all readonly names is printed.


       + return [ n ]

	   Causes a function to exit with the return value specified by n.  If
	   n is omitted, the return status is that of the last command
	   executed.


       + set [ -aefhkmntuvxP [ argument ... ] ]

	   The set commands supports the following options:

	   -a	 Mark variables which are modified or created for export.


	   -e	 Exit immediately if a command exits with a non-zero exit
		 status.


	   -f	 Disable file name generation.


	   -h	 Locate and remember function commands as functions are
		 defined (function commands are normally located when the
		 function is executed).


	   -k	 All keyword arguments are placed in the environment for a
		 command, not just those that precede the command name.


	   -m	 Switch job control mode on.  All jobs are run in their own
		 process groups.  See section Job Control (jsh) below.


	   -n	 Read commands but do not execute them.	 Setting -n in an
		 interactive shell is ignored as this could not be undone and
		 the shell could not even be terminated anymore.


	   -t	 Exit after reading and executing one command.


	   -u	 Treat unset variables as an error when substituting.


	   -v	 Print shell input lines as they are read.


	   -x	 Print commands and their arguments as they are executed.


	   -P	 Switch profile mode on.  In this mode, the shell runs
		 privilleged programs automatically in privilleged mode.  See
		 pfexec(1) for further information.  This feature is only
		 supported on Solaris 10 and above.  The option -P was not
		 supported in older versions of sh.


	   -	 Clear the -v and -x option.


	   --	 Stop option processing.  Further parameters are handled as
		 normal args even when they start with a -.

	   Using + rather than - causes these flags to be turned off.  These
	   flags can also be used upon invocation of the shell.	 The flags -c,
	   -i, -p, -r and -s can only be set upon invocation of the shell,
	   they cannot be modified using the set command.  The current set of
	   flags can be found in $-.  The remaining arguments are positional
	   parameters and are assigned, in order, to $1, $2, ...

	   If no arguments are given, the names and values of all variables
	   are printed.


       + shift [ n ]

	   The positional parameters from $n+1 ... are renamed $1 ... . If n
	   is not given, it is assumed to be 1.


       stop pid ...

	   Halt execution of the process number pid.  (see ps(1)).


       suspend

	   Stops the execution of the current shell (but not if it is the
	   login shell).


       test [expr]

	   Evaluate conditional expressions. See test(1) for usage and
	   description. If the value of the expression expr, is true then test
	   returns zero exit status; otherwise, a non zero exit status is
	   returned.  test returns a non zero exit status if there are no
	   arguments.

	   The following primaries are used to evaluate a condition:

	   -b file   True if file exists and is a block special file.
	   -c file   True if file exists and is a character special file.
	   -d file   True if file exists and is a directory.
	   -f file   True if file exists and is a regular file.
		     Alternatively, if Bourne Shell users specify /usr/ucb
		     before /usr/bin in their PATH environment variable, then
		     test returns true if file exists and is
		     (not-a-directory).
	   -g file   True if file exists and its set group ID flag is set.
	   -h file   True if file exists and is a symbolic link.
	   -k file   True if file exists and has its set sticky bit set.
	   -L file   True if file exists and is a symbolic link.
	   -n string True if the length of string is non-zero.
		     -p file True if file exists and is a named pipe (FIFO).
	   -r file   True if file exists and is readable.
	   -s file   True if file exists and has a size greater then zero.
	   -t [file-descriptor]
		     True if the file whose file descriptor number is
		     file-descriptor is open and is associated with a
		     terminal.	If file-descriptor is not specified, 1 is used
		     as a default value.
	   -u file   True if file exists and its set user ID flag is set.
	   -w file   True if file exists and is writable.
	   -x file   True if file exists and is executable.  True indicates
		     only that the execute flag is on.	If file is a
		     directory, true indicates that file can be searched.
	   -z string True if the length of string is zero.

	   string    True if string is not the null string.
	   s1 = s2   True if the strings s1 and s2 are identical.
	   s1 != s2  True if the strings s1 and s2 are not identical.
	   n1 -eq n2 True if the integers n1 and n2 are algebraically equal.
	   n1 -ne n2 True if the integers n1 and n2 are not algebraically
		     equal.
	   n1 -gt n2 True if the integer n1 is algebraically greater than the
		     integer n2.
	   n1 -ge n2 True if the integer n1 is algebraically greater or equal
		     to the integer n2.
	   n1 -lt n2 True if the integer n1 is algebraically less than the
		     integer n2.
	   n1 -le n2 True if the integer n1 is algebraically less or equal to
		     the integer n2.

	   The primaries above may be combined with the following operators:

	   ( expr )  Bracketing to group precedence.
	   !	     unary negation operator.
	   -a	     binary and operator.  The -a binary primary is left
		     associative and has higher precedence than the -o binary
		     primary.
	   -o	     binary or operator.  The -o binary primary is left
		     associative.


	   + times

		     Print the accumulated user and system times for processes
		     run from the shell.

		     The first line lists the shell's user and system times,
		     the second line lists the children's user and system
		     times.


	   + trap [ [argument] n [ n2 ... ]]

		     The command argument is to be read and executed when the
		     shell receives numeric or symbolic signal(s) (n).	(Note:
		     argument is scanned once when the trap is set and once
		     when the trap is taken.) Trap commands are executed in
		     order of signal number or corresponding symbolic names.
		     Any attempt to set a trap on a signal that was ignored on
		     entry to the current shell is ineffective.

		     If argument is absent, all trap(s) n are reset to their
		     original values. If argument is the null string, this
		     signal is ignored by the shell and by the commands it
		     invokes. If n is 0 or EXIT, the command argument is
		     executed on exit from the shell. The trap command with no
		     arguments prints a list of commands associated with each
		     signal number.


	   type [ name ... ]

		     For each name, indicate how it would be interpreted if
		     used as a command name.  type displays information about
		     each operand identifying the operand as a shell built-in,
		     shell intrinsic, function, hashed command, or keyword,
		     and where applicable, may display the operand's path
		     name.  The meaning is as follows:

		     shell built-in    A normal command built into the shell.
				       Some of these commands do not need to
				       be built into the shell.	 A command
				       usually is in this group because it was
				       built into the shell for historical
				       reasons or because it is an extension
				       to the current POSIX standard.

		     special shell built-in
				       A command built into the shell that is
				       subject to special treatment.  This
				       type of commands needs to be built into
				       the shell in order to be able to have
				       the desired result.

		     shell intrinsic   A command built into the shell.	This
				       type of commands needs to be built into
				       the shell in order to be able to have
				       the desired result.

		     function	       A function defined in this shell.

		     keyword	       A keyword in the syntax of this shell.

		     command	       An external command identified by it's
				       path name.

		     hashed command    An external command that was already
				       subject to a path name search and
				       hashing.

	   ulimit [ [-HS] [-a | -McdefilLmnPqrRsStuv] ]
	   ulimit [ [-HS] [resource-option] ] limit

		     ulimit prints or sets hard or soft resource limits. These
		     limits are described in getrlimit(2).

		     If limit is not present, ulimit prints the specified
		     limits.  Any number of limits can be printed at one time.
		     The -a option prints all limits.

		     If limit is present, ulimit sets the specified limit to
		     limit.  The string unlimited requests that the current
		     limit, if any, be removed. Any user can set a soft limit
		     to any value less than or equal to the hard limit. Any
		     user can lower a hard limit. Only a user with appropriate
		     privileges can raise or remove a hard limit. See
		     getrlimit(2).

		     The -H option specifies a hard limit. The -S option
		     specifies a soft limit. If neither option is specified,
		     ulimit sets both limits and print the soft limit.

		     The following options specify the resource whose limits
		     are to be printed or set. If no option is specified, the
		     file size limit is printed or set.

		     -M	    address space limit (in kbytes), usually -v alias
		     -c	    maximum core file size (in 512-byte blocks)
		     -d	    maximum size of data segment or heap (in kbytes)
		     -e	    maximum scheduling priority
		     -f	    maximum file size (in 512-byte blocks)
		     -i	    maximum number of pending signals
		     -l	    maximum size of locked memory (in kbytes)
		     -L	    maximum number of file locks
		     -m	    maximum resident set size (in kbytes)
		     -n	    maximum file descriptor plus 1
		     -P	    maximum number of pseudo ttys
		     -q	    maximum number of POSIX message queues
		     -r	    maximum realtime priority
		     -R	    maximum realtime quantum (in usec)
		     -s	    maximum size of stack segment (in kbytes)
		     -S	    maximum size of swap (in kbytes)
		     -t	    maximum CPU time (in seconds)
		     -u	    maximum number of child processes
		     -v	    maximum size of virtual memory (in kbytes)

		     Not all resources are supported on all platforms.

		     Run the sysdef(1M) command to obtain the maximum possible
		     limits for your system. The values reported are in
		     hexadecimal, but can be translated into decimal numbers
		     using the bc(1) utility. See swap(1M).)

		     As an example of ulimit, to limit the size of a core file
		     dump to 0 Megabytes, type the following:

		       ulimit -c 0




	   umask [ mask ]

		     The user file-creation mask is set to mask (see
		     umask(1)).

		     If mask is omitted, the current value of the mask is
		     printed.


	   + unset [ name ... ]

		     For each name, remove the corresponding variable or
		     function value.  The variables PATH, PS1, PS2, MAILCHECK,
		     and IFS cannot be unset.  Readonly variables cannot be
		     unset.


	   wait [ n ]

		     Wait for your background process whose process id is n
		     and report its termination status. If n is omitted, all
		     your shell's currently active background processes are
		     waited for and the return code is zero.


   Job Control (jsh)
       When the shell is invoked as jsh or after set -m was called, Job
       Control is enabled in addition to all of the functionality described
       previously for sh.  Typically, Job Control is enabled for the
       interactive shell only. Non-interactive shells typically do not benefit
       from the added functionality of Job Control.


       With Job Control enabled, every command or pipeline the user enters at
       the terminal is called a job.  All jobs exist in one of the following
       states: foreground, background, or stopped. These terms are defined as
       follows:

	   1.	  A job in the foreground has read and write access to the
		  controlling terminal.

	   2.	  A job in the background is denied read access and has
		  conditional write access to the controlling terminal (see
		  stty(1)).

	   3.	  A stopped job is a job that has been placed in a suspended
		  state, usually as a result of a SIGTSTP signal (see
		  signal.h(3HEAD)).


       Every job that the shell starts is assigned a positive integer, called
       a job number which is tracked by the shell and is used as an identifier
       to indicate a specific job. Additionally, the shell keeps track of the
       current and previous jobs. The current job is the most recent job to be
       started or restarted. The previous job is the first non-current job.


       The acceptable syntax for a Job Identifier is of the form:


       %jobid


       where jobid can be specified in any of the following formats:

       % or +	    For the current job.


       -	    For the previous job.


       ?<string>    Specify the job for which the command line uniquely
		    contains string.


       n	    For job number n.


       pref	    Where pref is a unique prefix of the command name. For
		    example, if the command ls -l name were running in the
		    background, it could be referred to as %ls.	 pref cannot
		    contain blanks unless it is quoted.



       When Job Control is enabled, the following commands are added to the
       user's environment to manipulate jobs:

       bg [%jobid ...]

	   Resumes the execution of a stopped job in the background. If %jobid
	   is omitted the current job is assumed.


       fg [%jobid ...]

	   Resumes the execution of a stopped job in the foreground, also
	   moves an executing background job into the foreground. If %jobid is
	   omitted the current job is assumed.


       jobs [-p|-l] [%jobid ...]
       jobs -x command [arguments]

	   Reports all jobs that are stopped or executing in the background.
	   If %jobid is omitted, all jobs that are stopped or running in the
	   background is reported. The following options modify/enhance the
	   output of jobs:

	   -l	 Report the process group ID and working directory of the
		 jobs.


	   -p	 Report only the process group ID of the jobs.


	   -x	 Replace any jobid found in command or arguments with the
		 corresponding process group ID, and then execute command
		 passing it arguments.


       kill [ -signal | -s signal ] %jobid

	   Builtin version of kill to provide the functionality of the kill
	   command for processes identified with a jobid.


       stop %jobid ...

	   Stops the execution of a background job(s).


       suspend

	   Stops the execution of the current shell (but not if it is the
	   login shell).


       wait [%jobid ...]

	   wait builtin accepts a job identifier. If %jobid is omitted wait
	   behaves as described above under Special Commands.


   Large File Behavior
       The Bourne Shell is large file aware.  See largefile(5) for an extended
       description of the behavior of sh and jsh when encountering files
       greater than or equal to 2 Gbyte ( 2^31 bytes).

EXIT STATUS
       Errors detected by the shell, such as syntax errors, cause the shell to
       return a non-zero exit status. If the shell is being used non-
       interactively execution of the shell file is abandoned. Otherwise, the
       shell returns the exit status of the last command executed (see also
       the exit command above).

   jsh Only
       If the shell is invoked as jsh and an attempt is made to exit the shell
       while there are stopped jobs, the shell issues one warning:


       There are stopped jobs.


       This is the only message. If another exit attempt is made, and there
       are still stopped jobs they are sent a SIGHUP signal from the kernel
       and the shell is exited.

FILES
       /etc/profile   The system initialization file, executed for login
		      shells.
       $HOME/.profile The personal initialization file, executed for login
		      shells after /etc/profile.
       /tmp/sh*	      Used as temporary files for here documents (<<
		      redirection).
       /dev/null      NULL device used as stdin for non job-control background
		      jobs.
       /usr/lib/rsh   The location of the restricted Bourne Shell binary.

ATTRIBUTES
       See attributes(5) for descriptions of the following attributes:

   /usr/bin/sh, /usr/bin/jsh



       +----------------------------+-----------------------------+
       |      ATTRIBUTE TYPE	    |	    ATTRIBUTE VALUE	  |
       +----------------------------+-----------------------------+
       |Availability		    | SUNWcsu			  |
       +----------------------------+-----------------------------+
       |CSI			    | Enabled			  |
       +----------------------------+-----------------------------+

SEE ALSO
       Intro(1), bc(1), bosh(1), echo(1), getoptcvt(1), kill(1), bsh(1),
       ksh(1), ksh93(1), login(1), newgrp(1), pbosh(1), pfsh(1), pfexec(1),
       privileges(5), ps(1), pwd(1), set(1), shell_builtins(1), stty(1),
       test(1), umask(1), wait(1), waitid(2), rsh(1M), su(1M), swap(1M),
       sysdef(1M), dup(2), exec(2), fork(2), pipe(2), ulimit(2), getrlimit(2),
       setrlimit(2), setlocale(3C), signal.h(3HEAD), passwd(4), profile(4),
       attributes(5), environ(5), largefile(5), XPG4(5)

WARNINGS
       The use of setuid shell scripts is strongly discouraged.

NOTES
       For compatibility with the Thompson shell, ^ is a synonym for | as
       pipeline separator.  Do not use in new scripts.

       Words used for filenames in input/output redirection are not
       interpreted for filename generation (see File Name Generation section
       above). For example, cat file1 >a* creates a file named a*.

       The built-in command . file reads the whole file before any commands
       are executed.  When a command substitution, a set of commands from
       eval, dosh, repeat, command, fc, jobs or trap are parsed, the whole set
       of command are read at once.  alias and unalias commands in the file do
       not apply to any commands defined in the file or inside a set of
       commands executed with the named built-ins.


       Because commands in pipelines are run as separate processes, variables
       set in a pipeline have no effect on the parent shell.


       If the input or the output of a while or until loop is redirected, the
       commands in the loop are run in a sub-shell, and variables set or
       changed there have no effect on the parent process:

	    lastline=
	    while read line
	    do

		    lastline=$line
	    done < /etc/passwd
	    echo "lastline=$lastline"	    # lastline is empty!




       In these cases, the input or output can be redirected by using exec, as
       in the following example:

	    # Save standard input (file descriptor 0) as file
	    # descriptor 3, and redirect standard input from the file
	    /etc/passwd:

	    exec 3<&0		    # save standard input as fd 3
	    exec </etc/passwd	    # redirect input from file

	    lastline=
	    while read line
	    do
		    lastline=$line
	    done

	    exec 0<&3		    # restore standard input
	    exec 3<&-		    # close file descriptor 3
	    echo "$lastline"	    # lastline




       If you get the error message, "cannot fork, too many processes", try
       using the wait(1) command to clean up your background processes. If
       this doesn't help, the system process table is probably full or you
       have too many active foreground processes. There is a limit to the
       number of process ids associated with your login, and to the number the
       system can keep track of.


       Only the last process in a pipeline can be waited for.


       If a command is executed, and a command with the same name is installed
       in a directory in the search path before the directory where the
       original command was found, the shell continues to exec the original
       command.	 Use the hash -r command to correct this situation.


       The Bourne shell has a limitation on the effective UID for a process.
       If this UID is less than 100 (and not equal to the real UID of the
       process), then the UID is reset to the real UID of the process.


       If not in job control mode, the shell implements both foreground and
       background jobs in the same process group and they all receive the same
       signals, which can lead to unexpected behavior. It is, therefore,
       recommended to switch on job control mode via set -m in an interactive
       environment.

       Parameter assignments that precede a special builtin command affect the
       shell itself.  Parameter assignments that precede the call of a
       function are ignored.

       When the shell executes a shell script that attempts to execute a non-
       existent command interpreter, the shell returns an erroneous diagnostic
       message that the shell script file does not exist.


AUTHORS
       The Bourne Shell was initially written by Stephen Richard Bourne at
       Bell Labs in 1976.  The SVr4 release was written by various authors at
       AT&T in 1989.  The Bourne Shell was later maintained by various people
       at AT&T and Sun Microsystems.  Since 2006, the Bourne Shell is
       maintained by Joerg Schilling.


SOURCE DOWNLOAD
       The source code for the Bourne Shell is included in the schilytools
       project and may be retrieved from the schilytools project at
       Sourceforge at:

	   http://sourceforge.net/projects/schilytools/

       The download directory is:

	   http://sourceforge.net/projects/schilytools/files/

       Check for the schily-*.tar.bz2 archives.

       Separate project informations for the Schily Bourne Shell project may
       be retrieved from:

	   http://schilytools.sourceforge.net/bosh.html

OpenSolaris Bourne Shell	  2018/08/16				 sh(1)
